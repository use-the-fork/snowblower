#!/usr/bin/env bash
###############################################################################################
#
#  SnowBlower: All Flake No Fluff
#  https://github.com/use-the-fork/snowblower
#

set -e
set -o pipefail

# keep-sorted start

# From: https://github.com/kigster/bashmatic/blob/main/lib/output.sh#L94

# TODO: Add IsTerminal to commands

# Various Check functions

export LEFT_PREFIX="    "
# Credits: https://github.com/srid/flake-root/blob/master/flake-module.nix
# This function is used to find the flake root and set it as a env varible.
findUp() {
  ancestors=()
  while true; do
    if [[ -f $1 ]]; then
      echo "$PWD"
      exit 0
    fi
    ancestors+=("$PWD")
    if [[ $PWD == / ]] || [[ $PWD == // ]]; then
      echo "Unable to locate ${1}"
      exit 1
    fi
    cd ..
  done
function _i() {
  local msgid="$1"
  shift

  printf "${LEFT_PREFIX}${msgid}\n" "$@"
function _iBreak() {
  echo "${NC}"
function _iCloud() {
  _i "$@"
  _inlineFlake
  echo "${NC}"
function _iCommandSection() {
  local command_name="$1"
  local display_name="$2"
  shift 2
  local options=("$@")

  echo "${YELLOW}${display_name} Commands:${NC}"
  # snow docker restart
  # First pass: calculate the maximum width of command part
  local max_width=0
  local commands=()
  local descriptions=()

  for option in "${options[@]}"; do
    if [[ $option == *"|"* ]]; then
      IFS='|' read -r cmd desc <<<"$option"
      local cmd_text="snow -- ${command_name} ${cmd}"
      commands+=("$cmd_text")
      descriptions+=("$desc")
    else
      local cmd_text="snow -- ${command_name} ..."
      commands+=("$cmd_text")
      descriptions+=("Run a ${display_name} command")
    fi

    # Calculate width without color codes
    local width=${#cmd_text}
    if ((width > max_width)); then
      max_width=$width
    fi
  done

  # Second pass: print with aligned descriptions
  for i in "${!commands[@]}"; do
    local cmd_text="${commands[i]}"
    local desc="${descriptions[i]}"
    local padding_needed=$((max_width - ${#cmd_text} + 10))
    local padding=$(printf "%*s" $padding_needed "")

    echo "  ${GREEN}${cmd_text}${NC}${padding}${desc}"
  done

  echo
function _iError() {
  echo -n "${RED}"
  _i "$@"
  echo -n "${NC}"
function _iFail() {
  _iError "$@"
function _iNote() {
  echo -n "${BLUE}"
  _i "$@"
  echo -n "${NC}"
function _iOk() {
  _i "$@"
  _inlineCheck
  echo "${NC}"
function _iSnow() {
  _i "$@"
  _inlineFlake
  echo "${NC}"
function _iVerbose() {
  if [[ -v VERBOSE ]]; then
    _i "$@"
  fi
function _iWarn() {
  echo -n "${YELLOW}"
  _i "$@"
  echo -n "${NC}"
function _inlineCheck() {
  cursorUp 1
  printf "${GREEN} âœ”ï¸Ž ${NC}"
function _inlineCloud() {
  cursorUp 1
  printf " ðŸ’¨ ${NC}"
function _inlineCross() {
  cursorUp 1
  printf "${RED} âœ˜ ${NC}"
function _inlineFlake() {
  cursorUp 1
  printf " â„ï¸ ${NC}"
function _inlineNotOk() {
  inlineError
function _inlineNote() {
  cursorUp 1
  printf "      ${NC}"
function _inlineWarning() {
  cursorUp 1
  printf "${YELLOW} âœ± ${NC}"
# Function to ask user for confirmation before proceeding
function confirmAction {
  local message="$1"
  local response

  echo -n "${message} (y/N): "
  read -r response

  case "$response" in
  [yY] | [yY][eE][sS])
    return 0
    ;;
  *)
    echo "Operation cancelled."
    exit 0
    ;;
  esac
function cursorDown() {
  cursorDownBy "$@"
function cursorDownBy() {
  #   output.is-terminal && printf "\e[${1}B"
  printf "\e[${1:-"1"}B"
function cursorLeftBy() {
  #   output.is-terminal && printf "\e[${1}D"
  printf "\e[${1:-"1"}D"
function cursorRightBy() {
  #   output.is-terminal && printf "\e[${1}C"
  printf "\e[${1:-"1"}C"
function cursorUp() {
  cursorUpBy "$@"
function cursorUpBy() {
  printf "\e[${1:-"1"}A"
# Function that checks
function doRunChecks {
  if [ -z "$SB_SKIP_CHECKS" ]; then
    # Ensure that SnowBlower is running...
    if ! isSnowBlowerDockerContainerUp; then
      _iFail "${BOLD}SnowBlower is not running.${NC}" >&2
      _iNote "Run 'snow up' to start SnowBlower."
      exit 1
    fi

    # Determine if SnowBlower is currently up...
    if "${SB_DOCKER_COMPOSE_PATH[@]}" ps "$SB_APP_SERVICE" 2>&1 | grep 'Exit\|exited'; then
      _iWarn "${BOLD}Shutting down old SnowBlower processes...${NC}" >&2
      "${SB_DOCKER_COMPOSE_PATH[@]}" down >/dev/null 2>&1
      isNotRunning
    elif [ -z "$("${SB_DOCKER_COMPOSE_PATH[@]}" ps -q "$SB_APP_SERVICE")" ]; then
      isNotRunning
    fi
  fi
# Credits to https://github.com/nix-community/home-manager/blob/master/lib/bash/home-manager.sh
# The setup respects the `NO_COLOR` environment variable.
function doSetupColors() {
  BOLD=""
  DIM=""
  UNDERLINE=""
  BLINK=""
  REVERSE=""
  NC=""
  BLACK=""
  RED=""
  GREEN=""
  YELLOW=""
  BLUE=""
  MAGENTA=""
  CYAN=""
  WHITE=""

  # Enable colors for terminals, and allow opting out.
  if [[ ! -v NO_COLOR && -t 1 ]]; then
    # See if it supports colors.
    local ncolors
    ncolors=$(tput colors 2>/dev/null || echo 0)

    if [[ -n $ncolors && $ncolors -ge 8 ]]; then
      # Text attributes
      BOLD="$(tput bold)"
      DIM="$(tput dim)"
      UNDERLINE="$(tput smul)"
      BLINK="$(tput blink)"
      REVERSE="$(tput rev)"
      NC="$(tput sgr0)" # No Color

      # Regular colors
      BLACK="$(tput setaf 0)"
      RED="$(tput setaf 1)"
      GREEN="$(tput setaf 2)"
      YELLOW="$(tput setaf 3)"
      BLUE="$(tput setaf 4)"
      MAGENTA="$(tput setaf 5)"
      CYAN="$(tput setaf 6)"
      WHITE="$(tput setaf 7)"
    fi
  fi
function hasNix() {
  if [ -n "$SB_NIX_PATH" ]; then
    return 0
  else
    return 1
  fi
function isInsideDocker() {
  test -f /.dockerenv
function isInsideSnowblowerShell() {
  if [ -n "$SB_IN_SHELL" ]; then
    return 0
  else
    return 1
  fi
function isSnowBlowerDockerContainerUp {
  # Check if snowblower-dev service container exists and is running
  [ -n "$("$SB_DOCKER_COMPOSE_PATH" -f "$SB_SRC_ROOT/docker-compose.yml" ps -q "$SB_APP_SERVICE" 2>/dev/null)" ]
function isSnowBlowerUp {
  if ! isSnowBlowerDockerContainerUp; then
    _iError "SnowBlower is not running."
    _iNote "You must first run 'snow up'."
    exit 1
  fi
function shouldExit() {
  local -r exit_code="${1}"
  shift
  local -r expected="${1}"
  shift
  if [ "$exit_code" != "${expected:-0}" ]; then
    exit "${exit_code}"
  fi
getFileMd5Hash() {
  if [ -f "$1" ]; then
    echo $(echo "$1") | md5sum | cut -d' ' -f1
    return 0
  else
    return 1
  fi
}

# keep-sorted end

function doCreateTouchFile() {
  local filePath="$1"
  # Evaluate the path with variables
  filePath=$(eval echo "$filePath")

  # Check if the path is not already within the project root
  if [[ $filePath != "$SB_PROJECT_ROOT"* ]]; then
    filePath="${SB_PROJECT_ROOT}/${filePath}"
  fi

  # Create parent directory if it doesn't exist
  mkdir -p "$(dirname "$filePath")"

  # Touch the file to create it empty
  touch "$filePath"
  _iOk "Created touch file" "$filePath"
}

function doCreateDirectory() {
  local dirPath="$1"
  # Evaluate the path with variables
  dirPath=$(eval echo "$dirPath")

  # Check if the path is not already within the project root
  if [[ $dirPath != "$SB_PROJECT_ROOT"* ]]; then
    dirPath="${SB_PROJECT_ROOT}/${dirPath}"
  fi

  mkdir -p "$dirPath"
  _iOk "Created directory" "$dirPath"
}

function doCreateDirectories() {
  _iVerbose "Creating Directories" "${SB_PROJECT_ROOT}"
  doCreateDirectory '${SB_PROJECT_STATE}/npm'
  doCreateDirectory '${SB_PROJECT_STATE}/npm/config'
  doCreateDirectory '${SB_PROJECT_STATE}/pre_commit'
  doCreateDirectory '${SB_PROJECT_STATE}/aider'
  doCreateDirectory '${SB_PROJECT_STATE}/aider/cache'

}

function doCreateTouchFiles() {
  _iVerbose "Creating Touch Files in %s" "${SB_PROJECT_ROOT}"

}

# at this point we can setup colors etc.
doSetupColors

doCheckSystem() {
  UNAMEOUT="$(uname -s)"

  # Verify operating system is supported...
  case "${UNAMEOUT}" in
  Linux*) MACHINE=linux ;;
  Darwin*) MACHINE=mac ;;
  *) MACHINE="UNKNOWN" ;;
  esac

  if [ "$MACHINE" == "UNKNOWN" ]; then
    _iError "Unsupported operating system [$(uname -s)]." "SnowBlower supports macOS, Linux, and Windows (WSL2)." >&2
    exit 1
  fi
}

function doBoot() {

  _iVerbose "Set project root to" "${SB_SRC_ROOT}"

  # Only source this once.

  if [ -f "$SB_SESS_FILE" ]; then
    source "$SB_SESS_FILE"
    _iVerbose "Found session at %s" "${SB_SESS_FILE}"

    # Split the SB_DOCKER_COMPOSE string into an array
    read -ra SB_DOCKER_COMPOSE_COMMAND <<<"$SB_DOCKER_COMPOSE"
    return 0
  fi

  _iOk "Creating Session File %s" "${SB_SESS_FILE}"

  # These are the must have varibles for the project
  export SB_PROJECT_ROOT="$SB_SRC_ROOT/.snowblower"
  export SB_PROJECT_PROFILE="$SB_PROJECT_ROOT/profile"
  export SB_PROJECT_STATE="$SB_PROJECT_ROOT/state"
  export SB_PROJECT_RUNTIME="$SB_PROJECT_ROOT/runtime"

  # Save exports to session file
  echo "export SB_PROJECT_ROOT=\"$SB_PROJECT_ROOT\"" >>"$SB_SESS_FILE"
  echo "export SB_PROJECT_PROFILE=\"$SB_PROJECT_PROFILE\"" >>"$SB_SESS_FILE"
  echo "export SB_PROJECT_STATE=\"$SB_PROJECT_STATE\"" >>"$SB_SESS_FILE"
  echo "export SB_PROJECT_RUNTIME=\"$SB_PROJECT_RUNTIME\"" >>"$SB_SESS_FILE"

  # Check if Docker is installed
  if SB_DOCKER_PATH=$(command -v docker 2>/dev/null) && [ -n "$SB_DOCKER_PATH" ]; then
    export SB_DOCKER_PATH
    _iOk "Docker path set to %s" "${SB_DOCKER_PATH}"
    echo "export SB_DOCKER_PATH=\"$SB_DOCKER_PATH\"" >>"$SB_SESS_FILE"
  else
    doDestroySession
    _iError "Docker is not installed or not in PATH. Please install Docker to continue."
    exit 1
  fi

  # Check if Docker Compose is available
  if SB_DOCKER_COMPOSE_PATH=$(command -v docker-compose 2>/dev/null) && [ -n "$SB_DOCKER_COMPOSE_PATH" ]; then
    export SB_DOCKER_COMPOSE_PATH
    _iOk "Docker Compose path set to %s" "${SB_DOCKER_COMPOSE_PATH}"
    echo "export SB_DOCKER_COMPOSE_PATH=\"$SB_DOCKER_COMPOSE_PATH\"" >>"$SB_SESS_FILE"
  elif SB_DOCKER_COMPOSE_PATH=$(command -v podman-compose 2>/dev/null) && [ -n "$SB_DOCKER_COMPOSE_PATH" ]; then
    export SB_DOCKER_COMPOSE_PATH
    _iOk "Docker Compose path set to %s" "${SB_DOCKER_COMPOSE_PATH}"
    echo "export SB_DOCKER_COMPOSE_PATH=\"$SB_DOCKER_COMPOSE_PATH\"" >>"$SB_SESS_FILE"
  else
    doDestroySession
    _iError "Docker Compose is not installed or not in PATH. Please install Docker to continue."
    exit 1
  fi

  _iNote "SnowBlower root directory set to" "${SB_SRC_ROOT}"

  # Create directories if they don't exist
  if [ ! -d "$SB_PROJECT_ROOT" ]; then
    _iVerbose "Creating project directory" "${SB_PROJECT_ROOT}"
    mkdir -p "$SB_PROJECT_ROOT"
  fi
  if [ ! -d "$SB_PROJECT_PROFILE" ]; then
    _iVerbose "Creating profile directory" "${SB_PROJECT_PROFILE}"
    mkdir -p "$SB_PROJECT_PROFILE"
  fi

  if [ ! -d "$SB_PROJECT_STATE" ]; then
    _iVerbose "Creating state directory" "${SB_PROJECT_STATE}"
    mkdir -p "$SB_PROJECT_STATE"
  fi

  if [ ! -d "$SB_PROJECT_RUNTIME" ]; then
    _iVerbose "Creating runtime directory" "${SB_PROJECT_RUNTIME}"
    mkdir -p "$SB_PROJECT_RUNTIME"
  fi

  #Symlink SnowBlower to the profile
  ln -sf "${SB_SRC_ROOT}/snow" "${SB_PROJECT_PROFILE}/snow"

  # the below two function are added via a seperate package in files.nix.
  # But we need to boot it here so we can be sure all directories are created.
  doCreateDirectories
  doCreateTouchFiles

  return 0

}

function doSetupSession() {

  # Source the ".env" file so environment variables are available...
  # shellcheck source=/dev/null
  if [ -n "${APP_ENV+x}" ] && [ -n "$APP_ENV" ] && [ -f ./.env."$APP_ENV" ]; then
    source ./.env."$APP_ENV"
    _iNote "Found and sourced %s" ".env.{$APP_ENV}"
  elif [ -f ./.env ]; then
    source ./.env
    _iNote "Found and sourced %s" ".env"
  fi

  # Global constants that are used in many parts of the script
  export SB_APP_SERVICE=${APP_SERVICE:-"snowblower-dev"}
  export SB_USER_UID=${USER_UID:-$UID}
  export SB_USER_GID=${USER_GID:-$(id -g)}
  export SB_SKIP_CHECKS=${SKIP_CHECKS:-}
  export SB_PROJECT_ROOT_FILE=${PROJECT_ROOT_FILE:-"flake.nix"}

  # Create a session file in tmp dir. this allows us to do the "heavy" lifiting for the snow command one time.
  export SB_SESS_FILE="${SB_SRC_ROOT:-/tmp}/.snowblower/.sb_session"

  _iVerbose "Set project root to" "${SB_SRC_ROOT}"
}

function doSetRoot() {
  # We need to find our project root early on so downstream options can use it.
  SB_SRC_ROOT="$(findUp "flake.nix")"
  if [ $? -ne 0 ]; then
    _iError "Unable to locate project root. Make sure you're in a project directory with a flake.nix file"
    exit 1
  fi
  export SB_SRC_ROOT
}

function setupEnvironmentVariables() {
  # Only source this once.
  if [ -v __SB_SESS_VARS_SOURCED ]; then return; fi
  export __SB_SESS_VARS_SOURCED=1

  export DOCKWATCHDATA="${SB_PROJECT_STATE}/dockwatch"
  export NPM_CONFIG_CACHE="${SB_PROJECT_STATE}/npm"
  export NPM_CONFIG_TMP="${SB_PROJECT_STATE}/npm"
  export NPM_CONFIG_USERCONFIG="${SB_PROJECT_STATE}/npm/config"
  export PRE_COMMIT_HOME="${SB_PROJECT_STATE}/pre_commit"
}

setupEnvironmentVariables

# Additional help functions for internal Commands

function doHelp__snow {
  local commands=(
    # keep-sorted start
    "bash|Enter the application CLI"
    "build|Builds all containers in compose file"
    "down|Stop the application"
    "ps|Display the status of all containers"
    "reboot|Erase current session and reset vars"
    "switch|Regenerate all config files"
    "up -d|Start the application in the background"
    "update|Update all dependencies by updating the Flake (Nix flake update)"
    "up|Start the application"
    # keep-sorted end
  )

  _iCommandSection "" "SnowBlower" "${commands[@]}"
}

function displayAllResolvedCommands {
  doHelp__snow
  doHelp__agenix
  doHelp__ai
  doHelp__npm
  doHelp__pre-commit
  doHelp__treefmt

}
function doHelp__agenix {
  local commands=('...|Run a Agenix command' 'rekey|Rekey secrets')
  _iCommandSection "agenix" "Agenix" "${commands[@]}"
}

function doHelp__ai {
  local commands=('...|Run a Aider command' 'gem|using Gemini as base' 'son|using Sonet as base')
  _iCommandSection "ai" "Aider" "${commands[@]}"
}

function doHelp__npm {
  local commands=('...|Run a NPM command')
  _iCommandSection "npm" "NPM" "${commands[@]}"
}

function doHelp__pre-commit {
  local commands=('...|Run a Pre-commit command' 'all|Run precommit on all files')
  _iCommandSection "pre-commit" "Pre-commit" "${commands[@]}"
}

function doHelp__treefmt {
  local commands=('...|Run a Treefmt command')
  _iCommandSection "treefmt" "Treefmt" "${commands[@]}"
}

function doHelp {
  echo "${YELLOW}Usage:${NC}" >&2
  echo "  snow [options] COMMAND SUBCOMMAND [arguments]"
  echo
  displayAllResolvedCommands
  echo
  exit 1
}

function doCommand__agenix { doRoutedCommandExecute sb-agenix "$@"; }
function doCommand__agenix__rekey {
  local cmd_args=(sb-agenix --rekey)
  doRoutedCommandExecute "${cmd_args[@]}" "$@"
}

function doCommand__ai { doRoutedCommandExecute aider "$@"; }
function doCommand__ai__gem {
  local cmd_args=(aider --model gemini --watch-files --no-suggest-shell-commands --no-detect-urls --git-commit-verify --lint-cmd treefmt)
  doRoutedCommandExecute "${cmd_args[@]}" "$@"
}

function doCommand__ai__son {
  local cmd_args=(aider --model sonnet --watch-files --no-suggest-shell-commands --no-detect-urls --git-commit-verify --read CONVENTIONS.MD --lint-cmd treefmt)
  doRoutedCommandExecute "${cmd_args[@]}" "$@"
}

function doCommand__npm { doRoutedCommandExecute npm "$@"; }

function doCommand__pre-commit { doRoutedCommandExecute pre-commit "$@"; }
function doCommand__pre-commit__all {
  local cmd_args=(pre-commit run --all-files)
  doRoutedCommandExecute "${cmd_args[@]}" "$@"
}

function doCommand__treefmt { doRoutedCommandExecute treefmt "$@"; }

# keep-sorted start

doDestroySession() {
  rm -f "$SB_SESS_FILE"
function doCommand__docker {
  "${SB_DOCKER_COMPOSE_PATH}" "$@"
  return $?
function doCommand__docker__bash {
  doRoutedCommandExecute bash
  return $?
function doCommand__docker__build {
  if [ $# -le 0 ]; then
    (cd "$SB_SRC_ROOT" && "${SB_DOCKER_COMPOSE_PATH}" build)
  else
    (cd "$SB_SRC_ROOT" && "${SB_DOCKER_COMPOSE_PATH}" build "$@")
  fi
  return $?
function doCommand__docker__down {
  doCommand__docker__stop
function doCommand__docker__ps {
  "${SB_DOCKER_COMPOSE_PATH}" ps
  return $?
function doCommand__docker__restart {
  if [ $# -le 0 ]; then
    (cd "$SB_SRC_ROOT" && "${SB_DOCKER_COMPOSE_PATH}" restart)
  else
    (cd "$SB_SRC_ROOT" && "${SB_DOCKER_COMPOSE_PATH}" restart "$@")
  fi
  return $?
function doCommand__docker__stop {
  if [ $# -le 0 ]; then
    (cd "$SB_SRC_ROOT" && "${SB_DOCKER_COMPOSE_PATH}" down)
  else
    (cd "$SB_SRC_ROOT" && "${SB_DOCKER_COMPOSE_PATH}" down "$@")
  fi
  return $?
# Commands that are specific to Docker and Docker Compose.
function doCommand__docker__up {
  if [ $# -le 0 ]; then
    (cd "$SB_SRC_ROOT" && "${SB_DOCKER_COMPOSE_PATH}" up)
  else
    (cd "$SB_SRC_ROOT" && "${SB_DOCKER_COMPOSE_PATH}" up "$@")
  fi
  return $?
# Figures out the type of envirment the command is running in and then routes approriatly.
function doRoutedCommandExecute() {

  _iVerbose "Attempting to run: $*"
  # If we are inside of a SnowBlower shell we run the command directly otherwise we need to proxy the command.
  if isInsideSnowblowerShell; then
    _i "Running: $*"
    exec "$@"
    return $?
  fi

  doRunChecks

  ARGS=()
  ARGS+=(exec -u "$SB_USER_UID")
  [ ! -t 0 ] && ARGS+=(-T)
  ARGS+=("$SB_APP_SERVICE")

  _iVerbose "Executing command via docker compose"

  # Execute the command with proper shell evaluation
  "$SB_DOCKER_COMPOSE_PATH" -f "$SB_SRC_ROOT/docker-compose.yml" "${ARGS[@]}" "$@"
  return $?
function doSnowDown {

  # Check if snowblower is running
  if ! isSnowBlowerDockerContainerUp; then
    _iExit "SnowBlower is already down."
    exit 0
  fi

  # If it's running, run docker compose down and wait for it to finish then run doDestroySession
  _iOk "Stopping SnowBlower services..."
  "$SB_DOCKER_COMPOSE_PATH" -f "$SB_SRC_ROOT/docker-compose.yml" down

  # Wait for docker compose to finish, then destroy session
  doDestroySession

  _iOk "SnowBlower has been stopped."
  exit 0
function doSnowReboot() {

  # Check if snowblower is running
  if isSnowBlowerDockerContainerUp; then
    confirmAction "A SnowBlower Docker instance is running. This action will shut down the current instance. Continue?"
  fi

  doSnowDown
  doSnowUp
  exit 0
function doSnowSwitch() {

  # Check if snowblower is running
  if isSnowBlowerDockerContainerUp; then
    confirmAction "A SnowBlower Docker instance is running. This action will shut down the current instance. Continue?"

    # If it's running, run docker compose down and wait for it to finish then run doDestroySession
    _iOk "Stopping SnowBlower services..."
    "$SB_DOCKER_COMPOSE_PATH" -f "$SB_SRC_ROOT/docker-compose.yml" down
  fi

  _iNote "Rebuilding Nix via Docker"
  "$SB_DOCKER_COMPOSE_PATH" -f "$SB_SRC_ROOT/docker-compose.yml" build

  # Start Docker in detached mode
  "$SB_DOCKER_COMPOSE_PATH" -f "$SB_SRC_ROOT/docker-compose.yml" up -d &
  DOCKER_COMPOSE_PID=$!

  wait $DOCKER_COMPOSE_PID

  _iNote "Running file generator..."
  doRoutedCommandExecute snowblower-files

  # Take it back down
  "$SB_DOCKER_COMPOSE_PATH" -f "$SB_SRC_ROOT/docker-compose.yml" down

  _iCloud "Switch Complete"

  # Wait for docker compose to finish, then destroy session
  doDestroySession

  exit 0
function doSnowUp {

  # Check if SnowBlower docker container is already running
  if isSnowBlowerDockerContainerUp; then
    _iError "SnowBlower container is already running. Use 'snow down' to stop it first."
    exit 1
  fi

  # Start docker-compose with interactive menu
  "$SB_DOCKER_COMPOSE_PATH" -f "$SB_SRC_ROOT/docker-compose.yml" up "$@" &
  DOCKER_COMPOSE_PID=$!

  # Wait for the process if not running in detached mode
  if [[ ! $* =~ -d|--detach ]]; then
    wait $DOCKER_COMPOSE_PID
  fi

  exit 0
# Commands that are specific to controling SnowBlower.
function doSnowUpdate {

  doRoutedCommandExecute nix flake update --extra-experimental-features nix-command --extra-experimental-features flakes
  doSnowSwitch
  doSnowReboot
  return 0
function hasHelpCommand() {
  local command="$1"

  # Check if the function exists for this command/subcommand combination
  if declare -f "doHelp__${command}" >/dev/null 2>&1; then
    return 0 # Function exists, so we can display help for it.
  else
    return 1 # Function doesn't exist, so no help is invalid
  fi
function hasSubCommand() {
  local command="$1"
  local subcommand="$2"

  # Check if the function exists for this command/subcommand combination
  if declare -f "doCommand__${command}__${subcommand}" >/dev/null 2>&1; then
    return 0 # Function exists, so subcommand is valid
  else
    return 1 # Function doesn't exist, so subcommand is invalid
  fi
# Function that outputs SnowBlower is not running...
function isNotRunning {
  echo
  _iFail "Environment is not running." >&2
  _i "To start run" "snow up"
  exit 1
}

# keep-sorted end

PASSTHROUGH_OPTS=()

SNOW_COMMAND=""
SNOW_COMMAND_ARGS=()

COMMAND=""
SUBCOMMAND=""
COMMAND_ARGS=()

# Split arguments at the `--` separator
BEFORE_SEPARATOR=()
AFTER_SEPARATOR=()

# Used here to split the function in to anything before '--' and after.
FOUND_SEPARATOR=false
for arg in "$@"; do
  if [[ $arg == "--" ]]; then
    FOUND_SEPARATOR=true
    continue
  fi

  if [[ $FOUND_SEPARATOR == true ]]; then
    AFTER_SEPARATOR+=("$arg")
  else
    BEFORE_SEPARATOR+=("$arg")
  fi
done

# Process snow-specific options and commands before `--`
i=0
while [[ $i -lt ${#BEFORE_SEPARATOR[@]} ]]; do
  opt="${BEFORE_SEPARATOR[$i]}"
  i=$((i + 1))

  case $opt in
  -v | --verbose)
    export VERBOSE=1
    ;;
  -h | --help)
    export HELP=1
    ;;
  --version)
    echo 25.11-pre
    exit 0
    ;;
  switch | up | down | update | reboot | help)
    SNOW_COMMAND="$opt"
    ;;
  *)
    case $SNOW_COMMAND in
    switch | update | reboot | up | down | help)
      SNOW_COMMAND_ARGS+=("$opt")
      ;;
    *)
      if [[ -z $SNOW_COMMAND ]]; then
        _iError "%s: unknown snow option '%s'. Use format: snow [options] -- command [args]" "$0" "$opt" >&2
        exit 1
      else
        SNOW_COMMAND_ARGS+=("$opt")
      fi
      ;;
    esac
    ;;
  esac
done

# Process environment commands and subcommands from after `--`
i=0
while [[ $i -lt ${#AFTER_SEPARATOR[@]} ]]; do
  opt="${AFTER_SEPARATOR[$i]}"
  i=$((i + 1))
  case $opt in
  agenix | ai | npm | pre-commit | treefmt)
    export COMMAND="$opt"
    ;;
  *)
    case $COMMAND in
    agenix | ai | npm | pre-commit | treefmt)
      export COMMAND_ARGS+=("$opt")
      ;;
    *)
      if [[ -z $COMMAND ]]; then
        _iError "%s: unknown command '%s'" "$0" "$opt" >&2
        _i "Run '%s --help' for usage help" "$0" >&2
        exit 1
      else
        export COMMAND_ARGS+=("$opt")
      fi
      ;;
    esac
    ;;
  esac
done

# Welcome Message
_iSnow "SnowBlower: All flake no fluff."

# find and set the root early on since we use it in our snow commands
doSetRoot

# we check the system to make sure we can run `SnowBlower`
doCheckSystem

# Now we setup our global vars
doSetupSession

# Lets GOOOO!!!!!
doBoot

# Parse subcommand from COMMAND_ARGS if needed
# This works becuase a sub command must come after a command
if [[ -n $COMMAND && ${#COMMAND_ARGS[@]} -gt 0 ]]; then
  potential_subcommand="${COMMAND_ARGS[0]}"

  if hasSubCommand "$COMMAND" "$potential_subcommand"; then
    export SUBCOMMAND="$potential_subcommand"
    export COMMAND_ARGS=("${COMMAND_ARGS[@]:1}")
  fi
fi

# Check if no `--` was found and no snow command was specified
if [[ $found_separator == false && -z $SNOW_COMMAND ]]; then
  doHelp >&2
  exit 1
fi

if [[ -n $HELP && -n $COMMAND ]]; then
  if hasHelpCommand "$COMMAND"; then
    doHelp__$COMMAND
    exit 1
  fi
fi

# Handle snow-specific commands first
if [[ -n $SNOW_COMMAND ]]; then
  case $SNOW_COMMAND in
  switch)
    doSnowSwitch "${SNOW_COMMAND_ARGS[@]}"
    ;;
  up)
    doSnowUp "${SNOW_COMMAND_ARGS[@]}"
    ;;
  down)
    doSnowDown "${SNOW_COMMAND_ARGS[@]}"
    ;;
  update)
    doSnowUpdate "${SNOW_COMMAND_ARGS[@]}"
    ;;
  reboot)
    doSnowReboot "${SNOW_COMMAND_ARGS[@]}"
    ;;
  help)
    doHelp "${SNOW_COMMAND_ARGS[@]}"
    ;;
  *)
    _iError 'Unknown snow command: %s' "$SNOW_COMMAND" >&2
    exit 1
    ;;
  esac
  exit 0
fi

# Handle environment commands
if [[ -z $COMMAND ]]; then
  doHelp >&2
  exit 1
fi

# None of the below should be run if SnowBlower is not up.
isSnowBlowerUp

case $COMMAND in
agenix)
  if [[ -n $SUBCOMMAND ]]; then
    if hasSubCommand "agenix" "$SUBCOMMAND"; then
      doCommand__agenix__$SUBCOMMAND "${COMMAND_ARGS[@]}"
    else
      doCommand__agenix "${COMMAND_ARGS[@]}"
    fi
  else
    doCommand__agenix "${COMMAND_ARGS[@]}"
  fi
  ;;
ai)
  if [[ -n $SUBCOMMAND ]]; then
    if hasSubCommand "ai" "$SUBCOMMAND"; then
      doCommand__ai__$SUBCOMMAND "${COMMAND_ARGS[@]}"
    else
      doCommand__ai "${COMMAND_ARGS[@]}"
    fi
  else
    doCommand__ai "${COMMAND_ARGS[@]}"
  fi
  ;;
npm)
  if [[ -n $SUBCOMMAND ]]; then
    if hasSubCommand "npm" "$SUBCOMMAND"; then
      doCommand__npm__$SUBCOMMAND "${COMMAND_ARGS[@]}"
    else
      doCommand__npm "${COMMAND_ARGS[@]}"
    fi
  else
    doCommand__npm "${COMMAND_ARGS[@]}"
  fi
  ;;
pre-commit)
  if [[ -n $SUBCOMMAND ]]; then
    if hasSubCommand "pre-commit" "$SUBCOMMAND"; then
      doCommand__pre-commit__$SUBCOMMAND "${COMMAND_ARGS[@]}"
    else
      doCommand__pre-commit "${COMMAND_ARGS[@]}"
    fi
  else
    doCommand__pre-commit "${COMMAND_ARGS[@]}"
  fi
  ;;
treefmt)
  if [[ -n $SUBCOMMAND ]]; then
    if hasSubCommand "treefmt" "$SUBCOMMAND"; then
      doCommand__treefmt__$SUBCOMMAND "${COMMAND_ARGS[@]}"
    else
      doCommand__treefmt "${COMMAND_ARGS[@]}"
    fi
  else
    doCommand__treefmt "${COMMAND_ARGS[@]}"
  fi
  ;;

*)
  _iError 'Unknown command: %s' "$COMMAND" >&2
  _i >&2
  exit 1
  ;;
esac
