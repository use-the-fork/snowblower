#!/usr/bin/env bash

set -e
set -o pipefail

# Credits to https://github.com/nix-community/home-manager/blob/master/lib/bash/home-manager.sh

# Sets up colors suitable for the `errorEcho`, `warnEcho`, and `noteEcho`
# functions.
#
# The check for terminal output and color support is heavily inspired by
# https://unix.stackexchange.com/a/10065.
#
# The setup respects the `NO_COLOR` environment variable.
function setupColors() {
    normalColor=""
    errorColor=""
    warnColor=""
    noteColor=""

    # Enable colors for terminals, and allow opting out.
    if [[ ! -v NO_COLOR && -t 1 ]]; then
        # See if it supports colors.
        local ncolors
        ncolors=$(tput colors 2> /dev/null || echo 0)

        if [[ -n "$ncolors" && "$ncolors" -ge 8 ]]; then
            normalColor="$(tput sgr0)"
            errorColor="$(tput bold)$(tput setaf 1)"
            warnColor="$(tput setaf 3)"
            noteColor="$(tput bold)$(tput setaf 6)"

            # Text attributes
            BOLD="$(tput bold)"
            DIM="$(tput dim)"
            # UNDERLINE="$(tput smul)"
            # BLINK="$(tput blink)"
            # REVERSE="$(tput rev)"
            NC="$(tput sgr0)"  # No Color

            # Regular colors
            BLACK="$(tput setaf 0)"
            RED="$(tput setaf 1)"
            GREEN="$(tput setaf 2)"
            YELLOW="$(tput setaf 3)"
            BLUE="$(tput setaf 4)"
            MAGENTA="$(tput setaf 5)"
            CYAN="$(tput setaf 6)"
            WHITE="$(tput setaf 7)"
        fi
    fi
}




setupColors

function statusEcho() {
    local status="${1:-}"
    local message="$2"
    local detail="${3:-}"
    
    if [ "$status" == "OK" ]; then
        echo "${WHITE}[ ${GREEN} OK ${WHITE} ]  ${NC}${DIM}${message}${NC} ${WHITE}${detail}${NC}"
    elif [ "$status" == "FAIL" ]; then
        echo "${WHITE}[ ${RED}FAIL${WHITE} ]  ${NC}${DIM}${message}${NC} ${WHITE}${detail}${NC}"
    elif [ "$status" == "WARN" ]; then
        echo "${WHITE}[ ${YELLOW}WARN${WHITE} ]  ${NC}${DIM}${message}${NC} ${WHITE}${detail}${NC}"
    elif [ "$status" == "INFO" ]; then
        echo "${WHITE}[ ${BLUE}INFO${WHITE} ]  ${NC}${DIM}${message}${NC} ${WHITE}${detail}${NC}"
    else
        echo "          ${NC}${DIM}${message}${NC} ${WHITE}${detail}${NC}"
    fi
}

function errorEcho() {
    echo "${errorColor}$*${normalColor}"
}

function warnEcho() {
    echo "${warnColor}$*${normalColor}"
}

function noteEcho() {
    echo "${noteColor}$*${normalColor}"
}

function verboseEcho() {
    if [[ -v VERBOSE ]]; then
        echo "$*"
    fi
}

function _i() {
    local msgid="$1"
    shift

    # shellcheck disable=2059
    printf "$("$msgid")\n" "$@"
}

function _ip() {
    local msgid="$1"
    local msgidPlural="$2"
    local count="$3"
    shift 3

    # shellcheck disable=2059
    printf "$("$msgid" "$msgidPlural" "$count")\n" "$@"
}

function _iError() {
    echo -n "${errorColor}"
    _i "$@"
    echo -n "${normalColor}"
}

function _iWarn() {
    echo -n "${warnColor}"
    _i "$@"
    echo -n "${normalColor}"
}

function _iNote() {
    echo -n "${noteColor}"
    _i "$@"
    echo -n "${normalColor}"
}

function _iVerbose() {
    if [[ -v VERBOSE ]]; then
        _i "$@"
    fi
}

# Credits: https://github.com/srid/flake-root/blob/master/flake-module.nix
# This function is used to find the flake root and set it as a env varible.
__sb__findUp() {
    ancestors=()
    while true; do
    if [[ -f $1 ]]; then
        echo "$PWD"
        exit 0
    fi
    ancestors+=("$PWD")
    if [[ $PWD == / ]] || [[ $PWD == // ]]; then
        echo "ERROR: Unable to locate the ${config.flake-root.projectRootFile} in any of: ''${ancestors[*]@Q}" >&2
        exit 1
    fi
    cd ..
    done
}

function __sb__createDirectory() {
    local dirPath="$1"
    # Evaluate the path with variables
    dirPath=$(eval echo "$dirPath")

    # Check if the path is not already within the project root
    if [[ "$dirPath" != "$SB_PROJECT_ROOT"* ]]; then
        dirPath="${SB_PROJECT_ROOT}/${dirPath}"
    fi

    mkdir -p "$dirPath"
    statusEcho "" "Created directory" "$dirPath"
}

# Various Check functions

function __sb__isInsideDocker(){
    test -f /.dockerenv
}

function __sb__hasNix(){
    if [ -n "$SB_NIX_PATH" ]; then
        return 0
    else
        return 1
    fi
}

  function __sb__createDirectories() {
  statusEcho "OK" "Creating Directories" "${SB_PROJECT_ROOT}"
  __sb__createDirectory '${SB_PROJECT_STATE}/npm'
__sb__createDirectory '${SB_PROJECT_STATE}/npm/config'

}


  UNAMEOUT="$(uname -s)"

# Verify operating system is supported...
case "${UNAMEOUT}" in
    Linux*)             MACHINE=linux;;
    Darwin*)            MACHINE=mac;;
    *)                  MACHINE="UNKNOWN"
esac

if [ "$MACHINE" == "UNKNOWN" ]; then
    statusEcho "FAIL" "Unsupported operating system [$(uname -s)]." "SnowBlower supports macOS, Linux, and Windows (WSL2)." >&2
    exit 1
fi


# Source the ".env" file so environment variables are available...
# shellcheck source=/dev/null
if [ -n "${APP_ENV+x}" ] && [ -n "$APP_ENV" ] && [ -f ./.env."$APP_ENV" ]; then
  source ./.env."$APP_ENV";
  statusEcho "OK" "Found and sources" ".env.{$APP_ENV}"
elif [ -f ./.env ]; then
  source ./.env;
  statusEcho "OK" "Found and sourced" ".env"
fi
``
# Create a session file in tmp dir. this allows us to do the "heavy" lifiting for the snow command one time.
export SB_SESS_FILE="${TMPDIR:-/tmp}/.sb_session_$(tty | tr '/' '_')"

# we define environment variables...
export SB_APP_SERVICE=${APP_SERVICE:-"snowblower-dev"}
export SB_USER_UID=${USER_UID:-$UID}
export SB_USER_GID=${USER_GID:-$(id -g)}
export SB_SKIP_CHECKS=${SKIP_CHECKS:-}


function __sb__bootSnowBlowerEnvironment() {
    # Only source this once.

    if [ -f "$SB_SESS_FILE" ]; then
        source "$SB_SESS_FILE"
        statusEcho "OK" "Found session at" "${SB_SESS_FILE}"
        return
    fi

    statusEcho "" "Booting SnowBlower Session" ""
    statusEcho "OK" "Creating Session File" "${SB_SESS_FILE}"

    # These are the must have varibles for the project
    export SB_SRC_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    export SB_PROJECT_ROOT="$SB_SRC_ROOT/.snowblower"
    export SB_PROJECT_PROFILE="$SB_PROJECT_ROOT/profile"
    export SB_PROJECT_STATE="$SB_PROJECT_ROOT/state"
    export SB_PROJECT_RUNTIME="$SB_PROJECT_ROOT/runtime"
    
    # Save exports to session file
    echo "export SB_SRC_ROOT=\"$SB_SRC_ROOT\"" > "$SB_SESS_FILE"
    echo "export SB_PROJECT_ROOT=\"$SB_PROJECT_ROOT\"" >> "$SB_SESS_FILE"
    echo "export SB_PROJECT_PROFILE=\"$SB_PROJECT_PROFILE\"" >> "$SB_SESS_FILE"
    echo "export SB_PROJECT_STATE=\"$SB_PROJECT_STATE\"" >> "$SB_SESS_FILE"
    echo "export SB_PROJECT_RUNTIME=\"$SB_PROJECT_RUNTIME\"" >> "$SB_SESS_FILE"
    

    if ! __sb__isInsideDocker; then
        # Check if Docker is installed
        export SB_DOCKER_PATH=$(which docker 2>/dev/null)
        SB_DOCKER_STATUS=$?

        if [ $SB_DOCKER_STATUS -eq 0 ] && [ -n "$SB_DOCKER_PATH" ]; then
            # Command succeeded and returned a path                                                        
            statusEcho "OK" "Docker found at:" "{$SB_DOCKER_PATH}"
            echo "export SB_DOCKER_PATH=\"$SB_DOCKER_PATH\"" >> "$SB_SESS_FILE"
        else
            statusEcho "FAIL" "Docker is not installed or not in PATH. Please install Docker to continue."
            exit 1
        fi

        # Check if Docker Compose is available
        export SB_DOCKER_COMPOSE_PATH=$(which docker-compose 2>/dev/null)
        SB_DOCKER_COMPOSE_STATUS=$?
                                                                                                        
        if [ $SB_DOCKER_COMPOSE_STATUS -eq 0 ] && [ -n "$SB_DOCKER_COMPOSE_PATH" ]; then
            # Command succeeded and returned a path                                                        
            statusEcho "OK" "Docker Compose found at:" "{$SB_DOCKER_COMPOSE_PATH}"
            echo "export SB_DOCKER_COMPOSE_PATH=\"$SB_DOCKER_COMPOSE_PATH\"" >> "$SB_SESS_FILE"
        else
            statusEcho "FAIL" "Docker Compose is not installed or not in PATH. Please install Docker to continue."
            exit 1
        fi
    fi

    statusEcho "OK" "SnowBlower directory set to" "${SB_PROJECT_ROOT}"

    # Create directories if they don't exist
    if [ ! -d "$SB_PROJECT_ROOT" ]; then
        statusEcho "OK" "Creating project directory" "${SB_PROJECT_ROOT}"
        mkdir -p "$SB_PROJECT_ROOT"
    fi
    if [ ! -d "$SB_PROJECT_PROFILE" ]; then
        statusEcho "OK" "Creating profile directory" "${SB_PROJECT_PROFILE}"
        mkdir -p "$SB_PROJECT_PROFILE"
    fi

    if [ ! -d "$SB_PROJECT_STATE" ]; then
        statusEcho "OK" "Creating state directory" "${SB_PROJECT_STATE}"
        mkdir -p "$SB_PROJECT_STATE"
    fi

    if [ ! -d "$SB_PROJECT_RUNTIME" ]; then
        statusEcho "OK" "Creating runtime directory" "${SB_PROJECT_RUNTIME}"
        mkdir -p "$SB_PROJECT_RUNTIME"
    fi

    # this function is added via a seperate package in files.nix.
    # But we need to boot it here so we can be sure all directories are created.
    __sb__createDirectories

    # Check if we are running in a Nix Shell
    export SB_NIX_PATH=$(which nix 2>/dev/null)
    SB_NIX_STATUS=$?
                                                                                                    
    if [ $SB_NIX_STATUS -eq 0 ] && __sb__hasNix; then
        # Command succeeded and returned a path                                                        
        statusEcho "OK" "Nix found at:" "{$SB_NIX_PATH}"
        echo "export SB_NIX_PATH=\"$SB_NIX_PATH\"" >> "$SB_SESS_FILE"
    else
        statusEcho "FAIL" "Nix command not found, some features may be limited"
    fi

    echo "export __SB_SESS_BOOTED=1" >> "$SB_SESS_FILE"

    echo
}

__sb__bootSnowBlowerEnvironment

# Split the SB_DOCKER_COMPOSE string into an array
read -ra SB_DOCKER_COMPOSE_COMMAND <<< "$SB_DOCKER_COMPOSE"


  function setupEnvironmentVariables() {
  # Only source this once.
  if [ -v __SB_SESS_VARS_SOURCED ]; then return; fi
  export __SB_SESS_VARS_SOURCED=1

  export NPM_CONFIG_CACHE="${SB_PROJECT_STATE}/npm"
export NPM_CONFIG_TMP="${SB_PROJECT_STATE}/npm"
export NPM_CONFIG_USERCONFIG="${SB_PROJECT_STATE}/npm/config"
}

setupEnvironmentVariables


  function display_help {
    echo "â„ï¸ ðŸ’¨ SnowBlower: All flake no fluff."
    echo
    echo "${YELLOW}Usage:${NC}" >&2
    echo "  snow COMMAND [options] [arguments]"
    echo
    echo "${YELLOW}SnowBlower Commands:${NC}"
    echo "  ${GREEN}snow switch${NC}          Regenerate all config files"
    echo "  ${GREEN}snow update${NC}          Update all dependencies by updating the Flake (Nix flake update)"
    echo "  ${GREEN}snow reboot${NC}          Erase current session and reset vars"
    echo
    echo "${YELLOW}docker-compose Commands:${NC}"
    echo "  ${GREEN}snow docker up${NC}        Start the application"
    echo "  ${GREEN}snow docker up -d${NC}     Start the application in the background"
    echo "  ${GREEN}snow docker down${NC}      Stop the application"
    echo "  ${GREEN}snow docker restart${NC}   Restart the application"
    echo "  ${GREEN}snow docker build${NC}     Builds all containers in compose file"
    echo "  ${GREEN}snow docker ps${NC}        Display the status of all containers"
    echo
    __sb__displayResolvedCommands
    echo
    exit 1
}
  # Prints the resolved commands from the nix build.
function __sb__displayResolvedCommands {
    echo "${YELLOW}Aider Commands:${NC}"
echo "  ${GREEN}snow aider ...${NC}          Run a Aider command"
echo "  ${GREEN}snow aider start${NC}          w/ linting, watchfiles, and conventions."

echo

echo "${YELLOW}NPM Commands:${NC}"
echo "  ${GREEN}snow npm ...${NC}          Run a NPM command"


echo


echo "${YELLOW}Treefmt Commands:${NC}"
echo "  ${GREEN}snow treefmt ...${NC}          Run a Treefmt command"


echo


}


  # Proxy the "help" command...
if [ $# -gt 0 ]; then
    if [ "$1" == "help" ] || [ "$1" == "-h" ] || [ "$1" == "-help" ] || [ "$1" == "--help" ]; then
        display_help
    fi
else
    display_help
fi

  # Commands that are specific to Docker and Docker Compose.
function __sb__command__docker__up {
    if [ $# -le 1 ]; then
        "${SB_DOCKER_COMPOSE_COMMAND[@]}" up
    else                                
        "${SB_DOCKER_COMPOSE_COMMAND[@]}" up "$@"
    fi
    return $?
}

function __sb__command__docker__down {
    __sb__command__docker__stop
}

function __sb__command__docker__stop {
    if [ $# -le 1 ]; then
        "${SB_DOCKER_COMPOSE_COMMAND[@]}" down
    else                                
        "${SB_DOCKER_COMPOSE_COMMAND[@]}" down "$@"
    fi
    return $?
}

function __sb__command__docker__restart {
    if [ $# -le 1 ]; then
        "${SB_DOCKER_COMPOSE_COMMAND[@]}" restart
    else                                
        "${SB_DOCKER_COMPOSE_COMMAND[@]}" restart "$@"
    fi
    return $?
}

function __sb__command__docker__ps {
    "${SB_DOCKER_COMPOSE_COMMAND[@]}" ps
    return $?
}
function __sb__command__docker__build {
    if [ $# -le 1 ]; then
        "${SB_DOCKER_COMPOSE_COMMAND[@]}" build
    else                                
        "${SB_DOCKER_COMPOSE_COMMAND[@]}" build "$@"
    fi
    return $?
}
  # Commands that are specific to controling SnowBlower.
function __sb__command__switch {
     nix run .#snowblowerFiles
     return $?
}
function __sb__command__update {
     nix flake update
     return $?
}
function __sb__command__update {
     nix flake update
     return $?
}

function __sb__command__reboot() {
    rm -f "$SB_SESS_FILE"
    __sb__bootSnowBlowerEnvironment
    return 0
}
  function __sb__command__aider {
  __sb__RoutedCommandExecute "aider"
}

function __sb__command__aider__start {
               __sb__RoutedCommandExecute "aider --model sonnet --watch-files --no-suggest-shell-commands --no-detect-urls --git-commit-verify --read "CONVENTIONS.MD" --lint-cmd "snow treefmt""
           }


function __sb__command__npm {
  __sb__RoutedCommandExecute "npm"
}




function __sb__command__npm-dev {
  __sb__RoutedCommandExecute "npm run dev"
}




function __sb__command__treefmt {
  __sb__RoutedCommandExecute "treefmt"
}





# Function that outputs SnowBlower is not running...
function __sb__isNotRunning {
    errorEcho "${BOLD}SnowBlower is not running.${NC}" >&2
    echo "" >&2
    errorEcho "${BOLD}You may start docker using the following commands:${NC} 'snow up'" >&2

    exit 1
}

# Function that checks
function __sb__runChecks {
    if [ -z "$SB_SKIP_CHECKS" ]; then
        # Ensure that Docker is running...
        if ! docker info > /dev/null 2>&1; then
            errorEcho "${BOLD}Docker is not running.${NC}" >&2
            exit 1
        fi

        # Determine if SnowBlower is currently up...
        if "${SB_DOCKER_COMPOSE_PATH[@]}" ps "$SB_APP_SERVICE" 2>&1 | grep 'Exit\|exited'; then
            warnEcho "${BOLD}Shutting down old SnowBlower processes...${NC}" >&2

            "${SB_DOCKER_COMPOSE_PATH[@]}" down > /dev/null 2>&1

            __sb__isNotRunning
        elif [ -z "$("${SB_DOCKER_COMPOSE_PATH[@]}" ps -q "$SB_APP_SERVICE")" ]; then
            __sb__isNotRunning
        fi
    fi
}


# Figures out the type of envirment the command is running in and then routes approriatly.
function __sb__RoutedCommandExecute() {
    local cmd="$1"
    
    # Remove surrounding quotes if present
    cmd="${cmd//\'}"
    
    # If the env has Nix we can run the command directly
    if __sb__hasNix; then
        eval "$cmd"
        return $?
    fi

    # If in nix shell and in docker, execute via docker-compose
    __sb__runChecks
        
    ARGS=()
    ARGS+=(exec -u "$SB_USER_UID")
    [ ! -t 0 ] && ARGS+=(-T)
    ARGS+=("$SB_APP_SERVICE")

    # Execute the command with proper shell evaluation
    "${SB_DOCKER_COMPOSE_PATH[@]}" "${ARGS[@]}" bash -c "$cmd"
}

# Function to run dynamically generated command functions
function __sb__runCommand {
    local command_name="$1"
    local subcommand_name="$2"
    
    # First try the specific command+subcommand function
    local specific_function="__sb__command__${command_name}__${subcommand_name}"
    
    # Then try the general command function
    local general_function="__sb__command__${command_name}"
    
    # Check if the specific function exists
    if declare -f "$specific_function" > /dev/null; then
        # Execute the specific function with remaining arguments
        shift 2
        "$specific_function" "$@"
    # Check if the general function exists
    elif declare -f "$general_function" > /dev/null; then
        # Execute the general function with all subcommands
        shift 1
        "$general_function" "$@"
    else
        errorEcho "Unknown command: snow $command_name $subcommand_name"
        errorEcho "Run 'snow help' for a list of available commands."
        exit 1
    fi
}

# Check if $2 exists before passing it to run_command                                                
if [ $# -ge 2 ]; then                                                                                
    __sb__runCommand "$1" "$2"                                                                            
else                                                                                                 
    __sb__runCommand "$1" ""                                                                              
fi



