#!/usr/bin/env bash
###############################################################################################
#
#  SnowBlower: All Flake No Fluff
#  https://github.com/use-the-fork/snowblower
#

export TEXTDOMAINDIR=@OUT@/share/locale

set -e
set -o pipefail

function setVerboseArg() {
  if [[ -v VERBOSE ]]; then
    export VERBOSE_ARG="--verbose"
  else
    export VERBOSE_ARG=""
  fi
}

# Credits to https://github.com/nix-community/home-manager/blob/master/lib/bash/home-manager.sh
# The setup respects the `NO_COLOR` environment variable.
function setupColors() {
  BOLD=""
  DIM=""
  UNDERLINE=""
  BLINK=""
  REVERSE=""
  NC=""
  BLACK=""
  RED=""
  GREEN=""
  YELLOW=""
  BLUE=""
  MAGENTA=""
  CYAN=""
  WHITE=""

  # Enable colors for terminals, and allow opting out.
  if [[ ! -v NO_COLOR && -t 1 ]]; then
    # See if it supports colors.
    local ncolors
    ncolors=$(tput colors 2>/dev/null || echo 0)

    if [[ -n $ncolors && $ncolors -ge 8 ]]; then
      # Text attributes
      BOLD="$(tput bold)"
      DIM="$(tput dim)"
      UNDERLINE="$(tput smul)"
      BLINK="$(tput blink)"
      REVERSE="$(tput rev)"
      NC="$(tput sgr0)" # No Color

      # Regular colors
      BLACK="$(tput setaf 0)"
      RED="$(tput setaf 1)"
      GREEN="$(tput setaf 2)"
      YELLOW="$(tput setaf 3)"
      BLUE="$(tput setaf 4)"
      MAGENTA="$(tput setaf 5)"
      CYAN="$(tput setaf 6)"
      WHITE="$(tput setaf 7)"
    fi
  fi
}

setupColors

function executeWithSpinner() {
  local message="$1"
  local command="$2"
  local detail="${3:-}"

  local spinner="â ‹â ™â ¹â ¸â ¼â ´â ¦â §â ‡â "
  local temp_file=$(mktemp)

  # Start command in background
  eval "$command" >"$temp_file" 2>&1 &
  local cmd_pid=$!

  # Show spinner while command runs
  local i=0
  while kill -0 $cmd_pid 2>/dev/null; do
    printf "\r${WHITE}[ ${BLUE}%s${WHITE} ]  ${NC}${DIM}%s${NC} ${WHITE}%s${NC}" \
      "${spinner:i:1}" "$message" "$detail"
    i=$(((i + 1) % ${#spinner}))
    sleep 0.1
  done

  # Wait for command to finish and get exit code
  wait $cmd_pid
  local exit_code=$?

  # Show final status
  if [ $exit_code -eq 0 ]; then
    echoOk "$message" "$detail"
  else
    echoFail "$message" "$detail"
    cat "$temp_file"
  fi

  rm -f "$temp_file"
  return $exit_code
}

function echoSnow() {
  local message="${1:-}"
  printf "${WHITE}[ â„ï¸ðŸ’¨ ]  ${BOLD}${WHITE}%s${NC}\n" "${message}"
}
function echoOk() {
  local message="${1:-}"
  local detail="${2:-}"
  printf "${WHITE}[ ${GREEN} OK ${WHITE} ]  ${NC}${DIM}%s${NC} ${WHITE}%s${NC}\n" "${message}" "${detail}"
}
function echoWarn() {
  local message="${1:-}"
  local detail="${2:-}"
  printf "${WHITE}[ ${YELLOW}WARN${WHITE} ]  ${NC}${DIM}%s${NC} ${WHITE}%s${NC}\n" "${message}" "${detail}"
}
function echoFail() {
  local message="${1:-}"
  local detail="${2:-}"
  printf "${WHITE}[ ${RED}FAIL${WHITE} ]  ${NC}${DIM}%s${NC} ${WHITE}%s${NC}\n" "${message}" "${detail}"
}
function echoInfo() {
  local message="${1:-}"
  local detail="${2:-}"
  printf "${WHITE}[ ${BLUE}INFO${WHITE} ]  ${NC}${DIM}%s${NC} ${WHITE}%s${NC}\n" "${message}" "${detail}"
}
function echoBlank() {
  local message="${1:-}"
  local detail="${2:-}"
  printf "          ${NC}${DIM}%s${NC} ${WHITE}%s${NC}\n" "${message}" "${detail}"
}

function echoHasVerbose() {
  local message="${1:-}"
  local detail="${2:-}"

  if [[ $VERBOSE != "no" ]] || [ -z "$VERBOSE" ]; then
    printf "${WHITE}[ ${YELLOW}ECHO${WHITE} ]  ${NC}${DIM}%s${NC} ${WHITE}%s${NC}\n" "${message}" "${detail}"
  fi
}
function echoDebug() {
  local message="${1:-}"
  local detail="${2:-}"

  if [ -n "${DEBUG:-}" ]; then
    printf "${WHITE}[ ${YELLOW}DEBUG${WHITE} ]  ${NC}${DIM}%s${NC} ${WHITE}%s${NC}\n" "${message}" "${detail}"
  fi
}

# #################################

function _i() {
  local msgid="$1"
  shift

  # shellcheck disable=2059
  printf "$msgid\n" "$@"
}

function _ip() {
  local msgid="$1"
  local msgidPlural="$2"
  local count="$3"
  shift 3

  # shellcheck disable=2059
  if [ "$count" -eq 1 ]; then
    printf "$msgid\n" "$@"
  else
    printf "$msgidPlural\n" "$@"
  fi
}

function _iError() {
  echo -n "${RED}"
  _i "$@"
  echo -n "${NC}"
}

function _iWarn() {
  echo -n "${YELLOW}"
  _i "$@"
  echo -n "${NC}"
}

function _iNote() {
  echo -n "${BLUE}"
  _i "$@"
  echo -n "${NC}"
}

function _iVerbose() {
  if [[ -v VERBOSE ]]; then
    _i "$@"
  fi
}

# Runs the given command on live run, otherwise prints the command to standard
# output.
#
# If given the command line option `--quiet`, then the command's standard output
# is sent to `/dev/null` on a live run.
#
# If given the command line option `--silence`, then the command's standard and
# error output is sent to `/dev/null` on a live run.
#
# The `--silence` and `--quiet` flags are mutually exclusive.
function run() {
  if [[ $1 == '--quiet' ]]; then
    local quiet=1
    shift
  elif [[ $1 == '--silence' ]]; then
    local silence=1
    shift
  fi

  if [[ -v DRY_RUN ]]; then
    echo "$@"
  elif [[ -v quiet ]]; then
    "$@" >/dev/null
  elif [[ -v silence ]]; then
    "$@" >/dev/null 2>&1
  else
    "$@"
  fi
}

# #################################

# Credits: https://github.com/srid/flake-root/blob/master/flake-module.nix
# This function is used to find the flake root and set it as a env varible.
findUp() {
  ancestors=()
  while true; do
    if [[ -f $1 ]]; then
      echo "$PWD"
      exit 0
    fi
    ancestors+=("$PWD")
    if [[ $PWD == / ]] || [[ $PWD == // ]]; then
      echo "Unable to locate ${1}"
      exit 1
    fi
    cd ..
  done
}

function createTouchFile() {
  local filePath="$1"
  # Evaluate the path with variables
  filePath=$(eval echo "$filePath")

  # Check if the path is not already within the project root
  if [[ $filePath != "$SB_PROJECT_ROOT"* ]]; then
    filePath="${SB_PROJECT_ROOT}/${filePath}"
  fi

  # Create parent directory if it doesn't exist
  mkdir -p "$(dirname "$filePath")"

  # Touch the file to create it empty
  touch "$filePath"
  echoBlank "Created touch file" "$filePath"
}

function createDirectory() {
  local dirPath="$1"
  # Evaluate the path with variables
  dirPath=$(eval echo "$dirPath")

  # Check if the path is not already within the project root
  if [[ $dirPath != "$SB_PROJECT_ROOT"* ]]; then
    dirPath="${SB_PROJECT_ROOT}/${dirPath}"
  fi

  mkdir -p "$dirPath"
  echoBlank "Created directory" "$dirPath"
}

# Various Check functions

function isInsideDocker() {
  test -f /.dockerenv
}

function hasNix() {
  if [ -n "$SB_NIX_PATH" ]; then
    return 0
  else
    return 1
  fi
}

function isInsideSnowblowerShell() {
  if [ -n "$SB_IN_SHELL" ]; then
    return 0
  else
    return 1
  fi
}

function __sb__createDirectories() {
  echoOk "Creating Directories" "${SB_PROJECT_ROOT}"
  __sb__createDirectory '${SB_PROJECT_STATE}/npm'
  __sb__createDirectory '${SB_PROJECT_STATE}/npm/config'
  __sb__createDirectory '${SB_PROJECT_STATE}/pre_commit'
  __sb__createDirectory '${SB_PROJECT_STATE}/aider'
  __sb__createDirectory '${SB_PROJECT_STATE}/aider/cache'

}

function __sb__createTouchFiles() {
  echoOk "Creating Touch Files" "${SB_PROJECT_ROOT}"

}

function doBoot() {
  UNAMEOUT="$(uname -s)"

  # Verify operating system is supported...
  case "${UNAMEOUT}" in
  Linux*) MACHINE=linux ;;
  Darwin*) MACHINE=mac ;;
  *) MACHINE="UNKNOWN" ;;
  esac

  if [ "$MACHINE" == "UNKNOWN" ]; then
    echoFail "Unsupported operating system [$(uname -s)]." "SnowBlower supports macOS, Linux, and Windows (WSL2)." >&2
    exit 1
  fi

  # Source the ".env" file so environment variables are available...
  # shellcheck source=/dev/null
  if [ -n "${APP_ENV+x}" ] && [ -n "$APP_ENV" ] && [ -f ./.env."$APP_ENV" ]; then
    source ./.env."$APP_ENV"
    echoOk "Found and sources" ".env.{$APP_ENV}"
  elif [ -f ./.env ]; then
    source ./.env
    echoOk "Found and sourced" ".env"
  fi

  # Create a session file in tmp dir. this allows us to do the "heavy" lifiting for the snow command one time.
  SCRIPT_HASH=$(echo "${BASH_SOURCE[0]}" | md5sum | cut -d' ' -f1 | cut -c1-8)
  export SB_SESS_FILE="${TMPDIR:-/tmp}/.sb_session_$(tty | tr '/' '_')_${SCRIPT_HASH}"

  # we define environment variables...
  export SB_APP_SERVICE=${APP_SERVICE:-"snowblower-dev"}
  export SB_USER_UID=${USER_UID:-$UID}
  export SB_USER_GID=${USER_GID:-$(id -g)}
  export SB_SKIP_CHECKS=${SKIP_CHECKS:-}
  export SB_PROJECT_ROOT_FILE=${PROJECT_ROOT_FILE:-"flake.nix"}

  SB_SRC_ROOT="$(findUp "$SB_PROJECT_ROOT_FILE")"
  if [ $? -ne 0 ]; then
    echoFail "Unable to locate $SB_PROJECT_ROOT_FILE" "Make sure you're in a project directory with a $SB_PROJECT_ROOT_FILE file"
    exit 1
  fi

  export SB_SRC_ROOT

  echoOk "Set project root to" "${SB_SRC_ROOT}"

  function bootSnowBlowerEnvironment() {
    # Only source this once.

    if [ -f "$SB_SESS_FILE" ]; then
      source "$SB_SESS_FILE"
      echoOk "Found session at" "${SB_SESS_FILE}"
      return
    fi

    echoSnow "Booting SnowBlower Session" ""
    echoOk "Creating Session File" "${SB_SESS_FILE}"

    # These are the must have varibles for the project
    export SB_PROJECT_ROOT="$SB_SRC_ROOT/.snowblower"
    export SB_PROJECT_PROFILE="$SB_PROJECT_ROOT/profile"
    export SB_PROJECT_STATE="$SB_PROJECT_ROOT/state"
    export SB_PROJECT_RUNTIME="$SB_PROJECT_ROOT/runtime"

    # Save exports to session file
    echo "export SB_PROJECT_ROOT=\"$SB_PROJECT_ROOT\"" >>"$SB_SESS_FILE"
    echo "export SB_PROJECT_PROFILE=\"$SB_PROJECT_PROFILE\"" >>"$SB_SESS_FILE"
    echo "export SB_PROJECT_STATE=\"$SB_PROJECT_STATE\"" >>"$SB_SESS_FILE"
    echo "export SB_PROJECT_RUNTIME=\"$SB_PROJECT_RUNTIME\"" >>"$SB_SESS_FILE"

    if ! isInsideDocker; then
      # Check if Docker is installed
      export SB_DOCKER_PATH=$(which docker 2>/dev/null)
      SB_DOCKER_STATUS=$?

      if [ $SB_DOCKER_STATUS -eq 0 ] && [ -n "$SB_DOCKER_PATH" ]; then
        # Command succeeded and returned a path
        echoOk "Docker found at:" "{$SB_DOCKER_PATH}"
        echo "export SB_DOCKER_PATH=\"$SB_DOCKER_PATH\"" >>"$SB_SESS_FILE"
      else
        echoFail "Docker is not installed or not in PATH. Please install Docker to continue."
        exit 1
      fi

      # Check if Docker Compose is available
      export SB_DOCKER_COMPOSE_PATH=$(which docker-compose 2>/dev/null)
      SB_DOCKER_COMPOSE_STATUS=$?

      # If docker-compose not found, try podman-compose
      if [ $SB_DOCKER_COMPOSE_STATUS -ne 0 ] || [ -z "$SB_DOCKER_COMPOSE_PATH" ]; then
        export SB_DOCKER_COMPOSE_PATH=$(which podman-compose 2>/dev/null)
        SB_DOCKER_COMPOSE_STATUS=$?
      fi

      if [ $SB_DOCKER_COMPOSE_STATUS -eq 0 ] && [ -n "$SB_DOCKER_COMPOSE_PATH" ]; then
        # Command succeeded and returned a path
        echoOk "Docker Compose found at:" "{$SB_DOCKER_COMPOSE_PATH}"
        echo "export SB_DOCKER_COMPOSE_PATH=\"$SB_DOCKER_COMPOSE_PATH\"" >>"$SB_SESS_FILE"
      else
        echoFail "Docker Compose is not installed or not in PATH. Please install Docker to continue."
        exit 1
      fi
    fi

    echoOk "SnowBlower root directory set to" "${SB_SRC_ROOT}"

    # Create directories if they don't exist
    if [ ! -d "$SB_PROJECT_ROOT" ]; then
      echoOk "Creating project directory" "${SB_PROJECT_ROOT}"
      mkdir -p "$SB_PROJECT_ROOT"
    fi
    if [ ! -d "$SB_PROJECT_PROFILE" ]; then
      echoOk "Creating profile directory" "${SB_PROJECT_PROFILE}"
      mkdir -p "$SB_PROJECT_PROFILE"
    fi

    if [ ! -d "$SB_PROJECT_STATE" ]; then
      echoOk "Creating state directory" "${SB_PROJECT_STATE}"
      mkdir -p "$SB_PROJECT_STATE"
    fi

    if [ ! -d "$SB_PROJECT_RUNTIME" ]; then
      echoOk "Creating runtime directory" "${SB_PROJECT_RUNTIME}"
      mkdir -p "$SB_PROJECT_RUNTIME"
    fi

    #Symlink SnowBlower to the profile
    ln -sf "${SB_SRC_ROOT}/snow" "${SB_PROJECT_PROFILE}/snow"

    # the below two function are added via a seperate package in files.nix.
    # But we need to boot it here so we can be sure all directories are created.
    createDirectories
    createTouchFiles

    # Check if we are running in a Nix Shell
    export SB_NIX_PATH=$(which nix 2>/dev/null)
    SB_NIX_STATUS=$?

    if [ $SB_NIX_STATUS -eq 0 ] && hasNix; then
      # Command succeeded and returned a path
      echoOk "Nix found at:" "{$SB_NIX_PATH}"
      echo "export SB_NIX_PATH=\"$SB_NIX_PATH\"" >>"$SB_SESS_FILE"
    else
      echoFail "Nix command not found, some features may be limited"
    fi

    echo "export __SB_SESS_BOOTED=1" >>"$SB_SESS_FILE"
    echo
  }

  bootSnowBlowerEnvironment

  # Split the SB_DOCKER_COMPOSE string into an array
  read -ra SB_DOCKER_COMPOSE_COMMAND <<<"$SB_DOCKER_COMPOSE"
}

function setupEnvironmentVariables() {
  # Only source this once.
  if [ -v __SB_SESS_VARS_SOURCED ]; then return; fi
  export __SB_SESS_VARS_SOURCED=1

  export NPM_CONFIG_CACHE="${SB_PROJECT_STATE}/npm"
  export NPM_CONFIG_TMP="${SB_PROJECT_STATE}/npm"
  export NPM_CONFIG_USERCONFIG="${SB_PROJECT_STATE}/npm/config"
  export PRE_COMMIT_HOME="${SB_PROJECT_STATE}/pre_commit"
}

setupEnvironmentVariables

function doHelp {
  echo "â„ï¸ ðŸ’¨ SnowBlower: All flake no fluff."
  echo
  echo "${YELLOW}Usage:${NC}" >&2
  echo "  snow COMMAND [options] [arguments]"
  echo
  echo "${YELLOW}SnowBlower Commands:${NC}"
  echo "  ${GREEN}snow switch${NC}          Regenerate all config files"
  echo "  ${GREEN}snow update${NC}          Update all dependencies by updating the Flake (Nix flake update)"
  echo "  ${GREEN}snow reboot${NC}          Erase current session and reset vars"
  echo
  echo "${YELLOW}docker-compose Commands:${NC}"
  echo "  ${GREEN}snow docker up${NC}        Start the application"
  echo "  ${GREEN}snow docker up -d${NC}     Start the application in the background"
  echo "  ${GREEN}snow docker down${NC}      Stop the application"
  echo "  ${GREEN}snow docker restart${NC}   Restart the application"
  echo "  ${GREEN}snow docker build${NC}     Builds all containers in compose file"
  echo "  ${GREEN}snow docker ps${NC}        Display the status of all containers"
  echo
  displayResolvedCommands
  echo
  exit 1
}

function displayResolvedCommands {
  echo "${YELLOW}Agenix Commands:${NC}"
  echo "  ${GREEN}snow agenix ...${NC}          Run a Agenix command"
  echo "  ${GREEN}snow agenix rekey${NC}          Rekey secrets"

  echo

  echo "${YELLOW}Aider Commands:${NC}"
  echo "  ${GREEN}snow ai ...${NC}          Run a Aider command"
  echo "  ${GREEN}snow ai gem${NC}          using Gemini as base"
  echo "  ${GREEN}snow ai start${NC}          w/ linting, watchfiles, and conventions."

  echo

  echo "${YELLOW}NPM Commands:${NC}"
  echo "  ${GREEN}snow npm ...${NC}          Run a NPM command"

  echo

  echo "${YELLOW}Pre-commit Commands:${NC}"
  echo "  ${GREEN}snow pre-commit ...${NC}          Run a Pre-commit command"
  echo "  ${GREEN}snow pre-commit all${NC}          Run precommit on all files"

  echo

}

function doCommand__agenix { doRoutedCommandExecute sb-agenix "$@"; }
function doCommand__agenix__rekey {
  local cmd_args=(sb-agenix --rekey)
  doRoutedCommandExecute "${cmd_args[@]}" "$@"
}

function doCommand__ai { doRoutedCommandExecute aider "$@"; }
function doCommand__ai__gem {
  local cmd_args=(aider --model gemini --watch-files --no-suggest-shell-commands --no-detect-urls --git-commit-verify --lint-cmd 'snow pre-commit all')
  doRoutedCommandExecute "${cmd_args[@]}" "$@"
}

function doCommand__ai__start {
  local cmd_args=(aider --model sonnet --watch-files --no-suggest-shell-commands --no-detect-urls --git-commit-verify --read CONVENTIONS.MD --lint-cmd 'snow pre-commit all')
  doRoutedCommandExecute "${cmd_args[@]}" "$@"
}

function doCommand__npm { doRoutedCommandExecute npm "$@"; }

function doCommand__npm-dev { doRoutedCommandExecute 'npm run dev' "$@"; }

function doCommand__pre-commit { doRoutedCommandExecute pre-commit "$@"; }
function doCommand__pre-commit__all {
  local cmd_args=(pre-commit run --all-files)
  doRoutedCommandExecute "${cmd_args[@]}" "$@"
}

# Commands that are specific to Docker and Docker Compose.
function doCommand__docker__up {
  cd $SB_SRC_ROOT
  echo "$@"
  echo "$#"
  if [ $# -le 1 ]; then
    "${SB_DOCKER_COMPOSE_PATH}" up
  else
    "${SB_DOCKER_COMPOSE_PATH}" up "$@"
  fi
  return $?
}

function doCommand__docker__down {
  doCommand__docker__stop
}

function doCommand__docker__stop {
  cd $SB_SRC_ROOT
  if [ $# -le 1 ]; then
    "${SB_DOCKER_COMPOSE_PATH}" down
  else
    "${SB_DOCKER_COMPOSE_PATH}" down "$@"
  fi
  return $?
}

function doCommand__docker__restart {
  cd $SB_SRC_ROOT
  if [ $# -le 1 ]; then
    "${SB_DOCKER_COMPOSE_PATH}" restart
  else
    "${SB_DOCKER_COMPOSE_PATH}" restart "$@"
  fi
  return $?
}

function doCommand__docker__ps {
  "${SB_DOCKER_COMPOSE_PATH}" ps
  return $?
}
function doCommand__docker__build {
  cd $SB_SRC_ROOT
  if [ $# -le 1 ]; then
    "${SB_DOCKER_COMPOSE_PATH}" build
  else
    "${SB_DOCKER_COMPOSE_PATH}" build "$@"
  fi
  return $?
}

function doCommand__docker {
  "${SB_DOCKER_COMPOSE_PATH}" "$@"
  return $?
}
# Commands that are specific to controling SnowBlower.
function doSwitch {
  (cd "$SB_SRC_ROOT" && nix run .#snowblowerFiles)
  return 0
}
function doUpdate {
  executeWithSpinner "Updating Flake" "nix flake update"
  doSwitch
  doReboot
  return 0
}

function doReboot() {
  rm -f "$SB_SESS_FILE"
  bootSnowBlowerEnvironment
  return 0
}

# Function that outputs SnowBlower is not running...
function isNotRunning {
  echo
  echoFail "Environment is not running." >&2
  echoBlank "To start run" "snow docker up"
  exit 1
}

# Function that checks
function doRunChecks {
  if [ -z "$SB_SKIP_CHECKS" ]; then
    # Ensure that Docker is running...
    if ! docker info >/dev/null 2>&1; then
      echoFail "${BOLD}Docker is not running.${NC}" >&2
      exit 1
    fi

    # Determine if SnowBlower is currently up...
    if "${SB_DOCKER_COMPOSE_PATH[@]}" ps "$SB_APP_SERVICE" 2>&1 | grep 'Exit\|exited'; then
      echoWarn "${BOLD}Shutting down old SnowBlower processes...${NC}" >&2
      "${SB_DOCKER_COMPOSE_PATH[@]}" down >/dev/null 2>&1
      isNotRunning
    elif [ -z "$("${SB_DOCKER_COMPOSE_PATH[@]}" ps -q "$SB_APP_SERVICE")" ]; then
      isNotRunning
    fi
  fi
}

# Figures out the type of envirment the command is running in and then routes approriatly.
function doRoutedCommandExecute() {
  # If we are inside of a SnowBlower shell we run the command directly otherwise we need to proxy the command.
  if isInsideSnowblowerShell; then
    echoDebug "$*"
    exec "$@"
    return $?
  fi

  # If in nix shell and in docker, execute via docker-compose
  doRunChecks

  ARGS=()
  ARGS+=(exec -u "$SB_USER_UID")
  [ ! -t 0 ] && ARGS+=(-T)
  ARGS+=("$SB_APP_SERVICE")

  # Execute the command with proper shell evaluation
  "${SB_DOCKER_COMPOSE_PATH[@]}" "${ARGS[@]}" with-nix "$@"
}

function hasSubCommand() {
  local command="$1"
  local subcommand="$2"

  # Check if the function exists for this command/subcommand combination
  if declare -f "doCommand__${command}__${subcommand}" >/dev/null 2>&1; then
    return 0 # Function exists, so subcommand is valid
  else
    return 1 # Function doesn't exist, so subcommand is invalid
  fi
}
# First we boot the SnowBlower Env
doBoot

PASSTHROUGH_OPTS=()
COMMAND=""
SUBCOMMAND=""
COMMAND_ARGS=()

# Phase 1: Find the main command
while [[ $# -gt 0 ]]; do
  opt="$1"
  shift
  case $opt in
  agenix | ai | npm | npm-dev | pre-commit | switch | update | reboot)
    COMMAND="$opt"
    ;;
  -v | --verbose)
    export VERBOSE=1
    ;;
  --version)
    echo 25.11-pre
    exit 0
    ;;
  *)
    case $COMMAND in
    agenix | ai | npm | npm-dev | pre-commit | switch)
      COMMAND_ARGS+=("$opt")
      ;;
    *)
      _iError "%s: unknown option '%s'" "$0" "$opt" >&2
      _i "Run '%s --help' for usage help" "$0" >&2
      exit 1
      ;;
    esac
    ;;
  esac
done

# Phase 2: Parse subcommand from COMMAND_ARGS if needed
if [[ -n $COMMAND && ${#COMMAND_ARGS[@]} -gt 0 ]]; then
  # First argument after command could be subcommand
  POTENTIAL_SUBCOMMAND="${COMMAND_ARGS[0]}"

  # Check if it's a valid subcommand for this command
  if hasSubCommand "$COMMAND" "$POTENTIAL_SUBCOMMAND"; then
    SUBCOMMAND="$POTENTIAL_SUBCOMMAND"
    # Remove subcommand from args, leaving only the flags/options
    COMMAND_ARGS=("${COMMAND_ARGS[@]:1}")
  fi
fi

if [[ -z $COMMAND ]]; then
  doHelp >&2
  exit 1
fi

case $COMMAND in
agenix)
  if [[ -n $SUBCOMMAND ]]; then
    if hasSubCommand "agenix" "$SUBCOMMAND"; then
      doCommand__agenix__$SUBCOMMAND "${COMMAND_ARGS[@]}"
    else
      doCommand__agenix "${COMMAND_ARGS[@]}"
    fi
  else
    doCommand__agenix "${COMMAND_ARGS[@]}"
  fi
  ;;
ai)
  if [[ -n $SUBCOMMAND ]]; then
    if hasSubCommand "ai" "$SUBCOMMAND"; then
      doCommand__ai__$SUBCOMMAND "${COMMAND_ARGS[@]}"
    else
      doCommand__ai "${COMMAND_ARGS[@]}"
    fi
  else
    doCommand__ai "${COMMAND_ARGS[@]}"
  fi
  ;;
npm)
  if [[ -n $SUBCOMMAND ]]; then
    if hasSubCommand "npm" "$SUBCOMMAND"; then
      doCommand__npm__$SUBCOMMAND "${COMMAND_ARGS[@]}"
    else
      doCommand__npm "${COMMAND_ARGS[@]}"
    fi
  else
    doCommand__npm "${COMMAND_ARGS[@]}"
  fi
  ;;
npm-dev)
  if [[ -n $SUBCOMMAND ]]; then
    if hasSubCommand "npm-dev" "$SUBCOMMAND"; then
      doCommand__npm-dev__$SUBCOMMAND "${COMMAND_ARGS[@]}"
    else
      doCommand__npm-dev "${COMMAND_ARGS[@]}"
    fi
  else
    doCommand__npm-dev "${COMMAND_ARGS[@]}"
  fi
  ;;
pre-commit)
  if [[ -n $SUBCOMMAND ]]; then
    if hasSubCommand "pre-commit" "$SUBCOMMAND"; then
      doCommand__pre-commit__$SUBCOMMAND "${COMMAND_ARGS[@]}"
    else
      doCommand__pre-commit "${COMMAND_ARGS[@]}"
    fi
  else
    doCommand__pre-commit "${COMMAND_ARGS[@]}"
  fi
  ;;

docker)
  if [[ -n $SUBCOMMAND ]]; then
    if hasSubCommand "docker" "$SUBCOMMAND"; then
      doCommand__docker__$SUBCOMMAND "${COMMAND_ARGS[@]}"
    else
      doCommand__docker "${COMMAND_ARGS[@]}"
    fi
  else
    doCommand__docker "${COMMAND_ARGS[@]}"
  fi
  ;;
switch)
  doSwitch
  ;;
update)
  doUpdate
  ;;
reboot)
  doUpdate
  ;;
help)
  doHelp
  ;;
*)
  _iError 'Unknown command: %s' "$COMMAND" >&2
  _i >&2
  exit 1
  ;;
esac
