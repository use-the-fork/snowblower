#!/usr/bin/env bash
###############################################################################################
#
#  SnowBlower: All Flake No Fluff
#  https://github.com/use-the-fork/snowblower
#

set -e
set -o pipefail

# Credits: https://github.com/srid/flake-root/blob/master/flake-module.nix
# This function is used to find the flake root and set it as a env varible.
findUp() {
  ancestors=()
  while true; do
    if [[ -f $1 ]]; then
      echo "$PWD"
      exit 0
    fi
    ancestors+=("$PWD")
    if [[ $PWD == / ]] || [[ $PWD == // ]]; then
      echo "Unable to locate ${1}"
      exit 1
    fi
    cd ..
  done
}

function createTouchFile() {
  local filePath="$1"
  # Evaluate the path with variables
  filePath=$(eval echo "$filePath")

  # Check if the path is not already within the project root
  if [[ $filePath != "$SB_PROJECT_ROOT"* ]]; then
    filePath="${SB_PROJECT_ROOT}/${filePath}"
  fi

  # Create parent directory if it doesn't exist
  mkdir -p "$(dirname "$filePath")"

  # Touch the file to create it empty
  touch "$filePath"
  echoBlank "Created touch file" "$filePath"
}

function createDirectory() {
  local dirPath="$1"
  # Evaluate the path with variables
  dirPath=$(eval echo "$dirPath")

  # Check if the path is not already within the project root
  if [[ $dirPath != "$SB_PROJECT_ROOT"* ]]; then
    dirPath="${SB_PROJECT_ROOT}/${dirPath}"
  fi

  mkdir -p "$dirPath"
  echoBlank "Created directory" "$dirPath"
}

# Various Check functions

function isInsideDocker() {
  test -f /.dockerenv
}

function hasNix() {
  if [ -n "$SB_NIX_PATH" ]; then
    return 0
  else
    return 1
  fi
}

function isInsideSnowblowerShell() {
  if [ -n "$SB_IN_SHELL" ]; then
    return 0
  else
    return 1
  fi
}

# Credits to https://github.com/nix-community/home-manager/blob/master/lib/bash/home-manager.sh
# The setup respects the `NO_COLOR` environment variable.
function doSetupColors() {
  BOLD=""
  DIM=""
  UNDERLINE=""
  BLINK=""
  REVERSE=""
  NC=""
  BLACK=""
  RED=""
  GREEN=""
  YELLOW=""
  BLUE=""
  MAGENTA=""
  CYAN=""
  WHITE=""

  # Enable colors for terminals, and allow opting out.
  if [[ ! -v NO_COLOR && -t 1 ]]; then
    # See if it supports colors.
    local ncolors
    ncolors=$(tput colors 2>/dev/null || echo 0)

    if [[ -n $ncolors && $ncolors -ge 8 ]]; then
      # Text attributes
      BOLD="$(tput bold)"
      DIM="$(tput dim)"
      UNDERLINE="$(tput smul)"
      BLINK="$(tput blink)"
      REVERSE="$(tput rev)"
      NC="$(tput sgr0)" # No Color

      # Regular colors
      BLACK="$(tput setaf 0)"
      RED="$(tput setaf 1)"
      GREEN="$(tput setaf 2)"
      YELLOW="$(tput setaf 3)"
      BLUE="$(tput setaf 4)"
      MAGENTA="$(tput setaf 5)"
      CYAN="$(tput setaf 6)"
      WHITE="$(tput setaf 7)"
    fi
  fi
}
# From: https://github.com/kigster/bashmatic/blob/main/lib/output.sh#L94

# TODO: Add IsTerminal to commands
#  Note that some function names end with : – this indicates that the function outputs a new-line in the end.

export LEFT_PREFIX="       "

function cursorRightBy() {
  #   output.is-terminal && printf "\e[${1}C"
  printf "\e[${1:-"1"}C"
}

function cursorLeftBy() {
  #   output.is-terminal && printf "\e[${1}D"
  printf "\e[${1:-"1"}D"
}

function cursorUpBy() {
  printf "\e[${1:-"1"}A"
}

function cursorDownBy() {
  #   output.is-terminal && printf "\e[${1}B"
  printf "\e[${1:-"1"}B"
}

function cursorUp() {
  cursorUpBy "$@"
}

function cursorDown() {
  cursorDownBy "$@"
}

function _inlineOk() {
  cursorUp 1
  printf "${GREEN} ✔︎    ${NC}"
}

function _inlineNotOk() {
  inlineError
}

function _inlineError() {
  cursorUp 1
  printf "${RED} ✘    ${NC}"
}

function _inlineWarning() {
  cursorUp 1
  printf "${YELLOW} ✱    ${NC}"
}

function _inlineNote() {
  cursorUp 1
  printf "      ${NC}"
}

function _iBreak() {
  echo "${NC}"
}

function _iSnowStart() {
  printf "${BLUE} ❄️    ${WHITE}$1${NC}\n"
}
function _iSnowEnd() {
  printf "${BLUE} 💨    ${WHITE}$1${NC}\n"
}

function _i() {
  printf -- "${LEFT_PREFIX}${NC}${DIM}$*${NC}\n"
}

function _iOk() {
  _i "$@"
  _inlineOk
  echo "${NC}"
}

function _iError() {
  _i "$@"
  _inlineError
  _iBreak
}

function _iFail() {
  _iError "$@"
}

function _iWarn() {
  _i "$@"
  _inlineWarning
  _iBreak
}

function _iNote() {
  _i "$@"
  _inlineNote
  _iBreak
}

function _iVerbose() {
  if [[ -v VERBOSE ]]; then
    _i "$@"
  fi
}

function __sb__createDirectories() {
  _iVerbose "Creating Directories" "${SB_PROJECT_ROOT}"
  __sb__createDirectory '${SB_PROJECT_STATE}/npm'
  __sb__createDirectory '${SB_PROJECT_STATE}/npm/config'
  __sb__createDirectory '${SB_PROJECT_STATE}/pre_commit'
  __sb__createDirectory '${SB_PROJECT_STATE}/aider'
  __sb__createDirectory '${SB_PROJECT_STATE}/aider/cache'

}

function __sb__createTouchFiles() {
  _iVerbose "Creating Touch Files" "${SB_PROJECT_ROOT}"

}

function doBoot() {
  # Colors first
  doSetupColors

  # Welcome Message
  _iSnowStart "SnowBlower: All flake no fluff."

  UNAMEOUT="$(uname -s)"

  # Verify operating system is supported...
  case "${UNAMEOUT}" in
  Linux*) MACHINE=linux ;;
  Darwin*) MACHINE=mac ;;
  *) MACHINE="UNKNOWN" ;;
  esac

  if [ "$MACHINE" == "UNKNOWN" ]; then
    _iError "Unsupported operating system [$(uname -s)]." "SnowBlower supports macOS, Linux, and Windows (WSL2)." >&2
    exit 1
  fi

  # Source the ".env" file so environment variables are available...
  # shellcheck source=/dev/null
  if [ -n "${APP_ENV+x}" ] && [ -n "$APP_ENV" ] && [ -f ./.env."$APP_ENV" ]; then
    source ./.env."$APP_ENV"
    _iNote "Found and sources" ".env.{$APP_ENV}"
  elif [ -f ./.env ]; then
    source ./.env
    _iNote "Found and sourced" ".env"
  fi

  # Create a session file in tmp dir. this allows us to do the "heavy" lifiting for the snow command one time.
  SCRIPT_HASH=$(echo "${BASH_SOURCE[0]}" | md5sum | cut -d' ' -f1 | cut -c1-8)
  export SB_SESS_FILE="${TMPDIR:-/tmp}/.sb_session_$(tty | tr '/' '_')_${SCRIPT_HASH}"

  # we define environment variables...
  export SB_APP_SERVICE=${APP_SERVICE:-"snowblower-dev"}
  export SB_USER_UID=${USER_UID:-$UID}
  export SB_USER_GID=${USER_GID:-$(id -g)}
  export SB_SKIP_CHECKS=${SKIP_CHECKS:-}
  export SB_PROJECT_ROOT_FILE=${PROJECT_ROOT_FILE:-"flake.nix"}

  SB_SRC_ROOT="$(findUp "$SB_PROJECT_ROOT_FILE")"
  if [ $? -ne 0 ]; then
    _iError "Unable to locate $SB_PROJECT_ROOT_FILE" "Make sure you're in a project directory with a $SB_PROJECT_ROOT_FILE file"
    exit 1
  fi

  export SB_SRC_ROOT

  _iVerbose "Set project root to" "${SB_SRC_ROOT}"

  function bootSnowBlowerEnvironment() {
    # Only source this once.

    if [ -f "$SB_SESS_FILE" ]; then
      source "$SB_SESS_FILE"
      _iVerbose "Found session at" "${SB_SESS_FILE}"
      return
    fi

    _iOk "Creating Session File" "${SB_SESS_FILE}"

    # These are the must have varibles for the project
    export SB_PROJECT_ROOT="$SB_SRC_ROOT/.snowblower"
    export SB_PROJECT_PROFILE="$SB_PROJECT_ROOT/profile"
    export SB_PROJECT_STATE="$SB_PROJECT_ROOT/state"
    export SB_PROJECT_RUNTIME="$SB_PROJECT_ROOT/runtime"

    # Save exports to session file
    echo "export SB_PROJECT_ROOT=\"$SB_PROJECT_ROOT\"" >>"$SB_SESS_FILE"
    echo "export SB_PROJECT_PROFILE=\"$SB_PROJECT_PROFILE\"" >>"$SB_SESS_FILE"
    echo "export SB_PROJECT_STATE=\"$SB_PROJECT_STATE\"" >>"$SB_SESS_FILE"
    echo "export SB_PROJECT_RUNTIME=\"$SB_PROJECT_RUNTIME\"" >>"$SB_SESS_FILE"

    if ! isInsideDocker; then
      # Check if Docker is installed
      export SB_DOCKER_PATH=$(which docker 2>/dev/null)
      SB_DOCKER_STATUS=$?

      if [ $SB_DOCKER_STATUS -eq 0 ] && [ -n "$SB_DOCKER_PATH" ]; then
        # Command succeeded and returned a path
        _iOk "Docker found at:" "{$SB_DOCKER_PATH}"
        echo "export SB_DOCKER_PATH=\"$SB_DOCKER_PATH\"" >>"$SB_SESS_FILE"
      else
        _iError "Docker is not installed or not in PATH. Please install Docker to continue."
        exit 1
      fi

      # Check if Docker Compose is available
      export SB_DOCKER_COMPOSE_PATH=$(which docker-compose 2>/dev/null)
      SB_DOCKER_COMPOSE_STATUS=$?

      # If docker-compose not found, try podman-compose
      if [ $SB_DOCKER_COMPOSE_STATUS -ne 0 ] || [ -z "$SB_DOCKER_COMPOSE_PATH" ]; then
        export SB_DOCKER_COMPOSE_PATH=$(which podman-compose 2>/dev/null)
        SB_DOCKER_COMPOSE_STATUS=$?
      fi

      if [ $SB_DOCKER_COMPOSE_STATUS -eq 0 ] && [ -n "$SB_DOCKER_COMPOSE_PATH" ]; then
        # Command succeeded and returned a path
        _iOk "Docker Compose found at:" "{$SB_DOCKER_COMPOSE_PATH}"
        echo "export SB_DOCKER_COMPOSE_PATH=\"$SB_DOCKER_COMPOSE_PATH\"" >>"$SB_SESS_FILE"
      else
        _iError "Docker Compose is not installed or not in PATH. Please install Docker to continue."
        exit 1
      fi
    fi

    _iNote "SnowBlower root directory set to" "${SB_SRC_ROOT}"

    # Create directories if they don't exist
    if [ ! -d "$SB_PROJECT_ROOT" ]; then
      _iVerbose "Creating project directory" "${SB_PROJECT_ROOT}"
      mkdir -p "$SB_PROJECT_ROOT"
    fi
    if [ ! -d "$SB_PROJECT_PROFILE" ]; then
      _iVerbose "Creating profile directory" "${SB_PROJECT_PROFILE}"
      mkdir -p "$SB_PROJECT_PROFILE"
    fi

    if [ ! -d "$SB_PROJECT_STATE" ]; then
      _iVerbose "Creating state directory" "${SB_PROJECT_STATE}"
      mkdir -p "$SB_PROJECT_STATE"
    fi

    if [ ! -d "$SB_PROJECT_RUNTIME" ]; then
      _iVerbose "Creating runtime directory" "${SB_PROJECT_RUNTIME}"
      mkdir -p "$SB_PROJECT_RUNTIME"
    fi

    #Symlink SnowBlower to the profile
    ln -sf "${SB_SRC_ROOT}/snow" "${SB_PROJECT_PROFILE}/snow"

    # the below two function are added via a seperate package in files.nix.
    # But we need to boot it here so we can be sure all directories are created.
    # createDirectories
    # createTouchFiles

    # Check if we are running in a Nix Shell
    export SB_NIX_PATH=$(which nix 2>/dev/null)
    SB_NIX_STATUS=$?

    if [ $SB_NIX_STATUS -eq 0 ] && hasNix; then
      # Command succeeded and returned a path
      _iOk "Nix found at:" "{$SB_NIX_PATH}"
      echo "export SB_NIX_PATH=\"$SB_NIX_PATH\"" >>"$SB_SESS_FILE"
    else
      _iError "Nix command not found, some features may be limited"
    fi

    echo "export __SB_SESS_BOOTED=1" >>"$SB_SESS_FILE"
  }

  bootSnowBlowerEnvironment

  # Split the SB_DOCKER_COMPOSE string into an array
  read -ra SB_DOCKER_COMPOSE_COMMAND <<<"$SB_DOCKER_COMPOSE"
}

function setupEnvironmentVariables() {
  # Only source this once.
  if [ -v __SB_SESS_VARS_SOURCED ]; then return; fi
  export __SB_SESS_VARS_SOURCED=1

  export NPM_CONFIG_CACHE="${SB_PROJECT_STATE}/npm"
  export NPM_CONFIG_TMP="${SB_PROJECT_STATE}/npm"
  export NPM_CONFIG_USERCONFIG="${SB_PROJECT_STATE}/npm/config"
  export PRE_COMMIT_HOME="${SB_PROJECT_STATE}/pre_commit"
}

setupEnvironmentVariables

function doHelp {
  echo "${YELLOW}Usage:${NC}" >&2
  echo "  snow [options] COMMAND SUBCOMMAND [arguments]"
  echo
  echo "${YELLOW}SnowBlower Commands:${NC}"
  echo "  ${GREEN}snow switch${NC}          Regenerate all config files"
  echo "  ${GREEN}snow update${NC}          Update all dependencies by updating the Flake (Nix flake update)"
  echo "  ${GREEN}snow reboot${NC}          Erase current session and reset vars"
  echo
  echo "${YELLOW}docker-compose Commands:${NC}"
  echo "  ${GREEN}snow docker up${NC}        Start the application"
  echo "  ${GREEN}snow docker up -d${NC}     Start the application in the background"
  echo "  ${GREEN}snow docker down${NC}      Stop the application"
  echo "  ${GREEN}snow docker restart${NC}   Restart the application"
  echo "  ${GREEN}snow docker build${NC}     Builds all containers in compose file"
  echo "  ${GREEN}snow docker ps${NC}        Display the status of all containers"
  echo
  displayResolvedCommands
  echo
  exit 1
}

function displayResolvedCommands {
  echo "${YELLOW}Agenix Commands:${NC}"
  echo "  ${GREEN}snow agenix ...${NC}          Run a Agenix command"
  echo "  ${GREEN}snow agenix rekey${NC}          Rekey secrets"

  echo

  echo "${YELLOW}Aider Commands:${NC}"
  echo "  ${GREEN}snow ai ...${NC}          Run a Aider command"
  echo "  ${GREEN}snow ai gem${NC}          using Gemini as base"
  echo "  ${GREEN}snow ai start${NC}          w/ linting, watchfiles, and conventions."

  echo

  echo "${YELLOW}NPM Commands:${NC}"
  echo "  ${GREEN}snow npm ...${NC}          Run a NPM command"

  echo

  echo "${YELLOW}Pre-commit Commands:${NC}"
  echo "  ${GREEN}snow pre-commit ...${NC}          Run a Pre-commit command"
  echo "  ${GREEN}snow pre-commit all${NC}          Run precommit on all files"

  echo

}

function doCommand__agenix { doRoutedCommandExecute sb-agenix "$@"; }
function doCommand__agenix__rekey {
  local cmd_args=(sb-agenix --rekey)
  doRoutedCommandExecute "${cmd_args[@]}" "$@"
}

function doCommand__ai { doRoutedCommandExecute aider "$@"; }
function doCommand__ai__gem {
  local cmd_args=(aider --model gemini --watch-files --no-suggest-shell-commands --no-detect-urls --git-commit-verify --lint-cmd 'snow pre-commit all')
  doRoutedCommandExecute "${cmd_args[@]}" "$@"
}

function doCommand__ai__start {
  local cmd_args=(aider --model sonnet --watch-files --no-suggest-shell-commands --no-detect-urls --git-commit-verify --read CONVENTIONS.MD --lint-cmd 'snow pre-commit all')
  doRoutedCommandExecute "${cmd_args[@]}" "$@"
}

function doCommand__npm { doRoutedCommandExecute npm "$@"; }

function doCommand__pre-commit { doRoutedCommandExecute pre-commit "$@"; }
function doCommand__pre-commit__all {
  local cmd_args=(pre-commit run --all-files)
  doRoutedCommandExecute "${cmd_args[@]}" "$@"
}

# Commands that are specific to Docker and Docker Compose.
function doCommand__docker__up {
  if [ $# -le 0 ]; then
    (cd "$SB_SRC_ROOT" && "${SB_DOCKER_COMPOSE_PATH}" up)
  else
    (cd "$SB_SRC_ROOT" && "${SB_DOCKER_COMPOSE_PATH}" up "$@")
  fi
  return $?
}

function doCommand__docker__down {
  doCommand__docker__stop
}

function doCommand__docker__stop {
  if [ $# -le 0 ]; then
    (cd "$SB_SRC_ROOT" && "${SB_DOCKER_COMPOSE_PATH}" down)
  else
    (cd "$SB_SRC_ROOT" && "${SB_DOCKER_COMPOSE_PATH}" down "$@")
  fi
  return $?
}

function doCommand__docker__restart {
  if [ $# -le 0 ]; then
    (cd "$SB_SRC_ROOT" && "${SB_DOCKER_COMPOSE_PATH}" restart)
  else
    (cd "$SB_SRC_ROOT" && "${SB_DOCKER_COMPOSE_PATH}" restart "$@")
  fi
  return $?
}

function doCommand__docker__ps {
  "${SB_DOCKER_COMPOSE_PATH}" ps
  return $?
}

function doCommand__docker__build {
  if [ $# -le 0 ]; then
    (cd "$SB_SRC_ROOT" && "${SB_DOCKER_COMPOSE_PATH}" build)
  else
    (cd "$SB_SRC_ROOT" && "${SB_DOCKER_COMPOSE_PATH}" build "$@")
  fi
  return $?
}

function doCommand__docker {
  "${SB_DOCKER_COMPOSE_PATH}" "$@"
  return $?
}
# Commands that are specific to controling SnowBlower.
function doSwitch {
  (cd "$SB_SRC_ROOT" && nix run .#snowblowerFiles)
  return 0
}
function doUpdate {
  executeWithSpinner "Updating Flake" "nix flake update"
  doSwitch
  doReboot
  return 0
}

function doReboot() {
  rm -f "$SB_SESS_FILE"
  doBoot
  return 0
}

# Function that outputs SnowBlower is not running...
function isNotRunning {
  echo
  _iFail "Environment is not running." >&2
  _i "To start run" "snow docker up"
  exit 1
}

# Function that checks
function doRunChecks {
  if [ -z "$SB_SKIP_CHECKS" ]; then
    # Ensure that Docker is running...
    if ! docker info >/dev/null 2>&1; then
      _iFail "${BOLD}Docker is not running.${NC}" >&2
      exit 1
    fi

    # Determine if SnowBlower is currently up...
    if "${SB_DOCKER_COMPOSE_PATH[@]}" ps "$SB_APP_SERVICE" 2>&1 | grep 'Exit\|exited'; then
      _iWarn "${BOLD}Shutting down old SnowBlower processes...${NC}" >&2
      "${SB_DOCKER_COMPOSE_PATH[@]}" down >/dev/null 2>&1
      isNotRunning
    elif [ -z "$("${SB_DOCKER_COMPOSE_PATH[@]}" ps -q "$SB_APP_SERVICE")" ]; then
      isNotRunning
    fi
  fi
}

# Figures out the type of envirment the command is running in and then routes approriatly.
function doRoutedCommandExecute() {
  _iVerbose "Attempting to run: $*"
  # If we are inside of a SnowBlower shell we run the command directly otherwise we need to proxy the command.
  if isInsideSnowblowerShell; then
    _i "Running: $*"
    exec "$@"
    return $?
  fi

  # If in nix shell and in docker, execute via docker-compose
  doRunChecks

  ARGS=()
  ARGS+=(exec -u "$SB_USER_UID")
  [ ! -t 0 ] && ARGS+=(-T)
  ARGS+=("$SB_APP_SERVICE")

  _iVerbose "Executing command via docker compose"
  # Execute the command with proper shell evaluation
  "${SB_DOCKER_COMPOSE_PATH[@]}" "${ARGS[@]}" with-nix "$@"
}

function hasSubCommand() {
  local command="$1"
  local subcommand="$2"

  # Check if the function exists for this command/subcommand combination
  if declare -f "doCommand__${command}__${subcommand}" >/dev/null 2>&1; then
    return 0 # Function exists, so subcommand is valid
  else
    return 1 # Function doesn't exist, so subcommand is invalid
  fi
}
doBoot

PASSTHROUGH_OPTS=()
COMMAND=""
SUBCOMMAND=""
COMMAND_ARGS=()

# Phase 1: Find the main command
while [[ $# -gt 0 ]]; do
  opt="$1"
  shift
  case $opt in
  agenix | ai | npm | pre-commit | switch | update | reboot | docker)
    COMMAND="$opt"
    ;;
  -v | --verbose)
    export VERBOSE=1
    ;;
  --version)
    echo 25.11-pre
    exit 0
    ;;
  *)
    case $COMMAND in
    agenix | ai | npm | pre-commit | switch | docker)
      COMMAND_ARGS+=("$opt")
      ;;
    *)
      _iError "%s: unknown option '%s'" "$0" "$opt" >&2
      _i "Run '%s --help' for usage help" "$0" >&2
      exit 1
      ;;
    esac
    ;;
  esac
done

# Phase 2: Parse subcommand from COMMAND_ARGS if needed
if [[ -n $COMMAND && ${#COMMAND_ARGS[@]} -gt 0 ]]; then
  # First argument after command could be subcommand
  POTENTIAL_SUBCOMMAND="${COMMAND_ARGS[0]}"

  # Check if it's a valid subcommand for this command
  if hasSubCommand "$COMMAND" "$POTENTIAL_SUBCOMMAND"; then
    SUBCOMMAND="$POTENTIAL_SUBCOMMAND"
    # Remove subcommand from args, leaving only the flags/options
    COMMAND_ARGS=("${COMMAND_ARGS[@]:1}")
  fi
fi

if [[ -z $COMMAND ]]; then
  doHelp >&2
  exit 1
fi

case $COMMAND in
agenix)
  if [[ -n $SUBCOMMAND ]]; then
    if hasSubCommand "agenix" "$SUBCOMMAND"; then
      doCommand__agenix__$SUBCOMMAND "${COMMAND_ARGS[@]}"
    else
      doCommand__agenix "${COMMAND_ARGS[@]}"
    fi
  else
    doCommand__agenix "${COMMAND_ARGS[@]}"
  fi
  ;;
ai)
  if [[ -n $SUBCOMMAND ]]; then
    if hasSubCommand "ai" "$SUBCOMMAND"; then
      doCommand__ai__$SUBCOMMAND "${COMMAND_ARGS[@]}"
    else
      doCommand__ai "${COMMAND_ARGS[@]}"
    fi
  else
    doCommand__ai "${COMMAND_ARGS[@]}"
  fi
  ;;
npm)
  if [[ -n $SUBCOMMAND ]]; then
    if hasSubCommand "npm" "$SUBCOMMAND"; then
      doCommand__npm__$SUBCOMMAND "${COMMAND_ARGS[@]}"
    else
      doCommand__npm "${COMMAND_ARGS[@]}"
    fi
  else
    doCommand__npm "${COMMAND_ARGS[@]}"
  fi
  ;;
pre-commit)
  if [[ -n $SUBCOMMAND ]]; then
    if hasSubCommand "pre-commit" "$SUBCOMMAND"; then
      doCommand__pre-commit__$SUBCOMMAND "${COMMAND_ARGS[@]}"
    else
      doCommand__pre-commit "${COMMAND_ARGS[@]}"
    fi
  else
    doCommand__pre-commit "${COMMAND_ARGS[@]}"
  fi
  ;;

docker)
  if [[ -n $SUBCOMMAND ]]; then
    if hasSubCommand "docker" "$SUBCOMMAND"; then
      doCommand__docker__$SUBCOMMAND "${COMMAND_ARGS[@]}"
    else
      doCommand__docker "${COMMAND_ARGS[@]}"
    fi
  else
    doCommand__docker "${COMMAND_ARGS[@]}"
  fi
  ;;
switch)
  doSwitch
  ;;
update)
  doUpdate
  ;;
reboot)
  doReboot
  ;;
help)
  doHelp
  ;;
*)
  _iError 'Unknown command: %s' "$COMMAND" >&2
  _i >&2
  exit 1
  ;;
esac
